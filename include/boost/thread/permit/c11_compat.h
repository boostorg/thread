/* c1x_compat.h
Declares and defines stuff from C11
(C) 2011-2014 Niall Douglas http://www.nedproductions.biz/


Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef C11_COMPAT_H
#define C11_COMPAT_H

#include <stdlib.h>
#include <errno.h>
#ifndef ETIMEDOUT
#define ETIMEDOUT       138
#endif

#if __STDC_VERSION__ < 199901L          /* not C99 or better */
#if !defined(PTHREAD_PERMIT_RESTRICT) && (defined(_MSC_VER) || defined(__GNUC__) || defined(__clang__))
#define PTHREAD_PERMIT_RESTRICT __restrict
#endif
#else
#define PTHREAD_PERMIT_RESTRICT restrict
#endif

#ifndef PTHREAD_PERMIT_RESTRICT
#define PTHREAD_PERMIT_RESTRICT
#endif

// If we have C11, just use that direct
#if __STDC_VERSION__ > 200000L

#include <stdatomic.h>
#include <threads.h>
typedef atomic_uint atomic_uint_c11_compat;

#else // Need to fake C11 support using a mixture of C++ and OS calls

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable: 4100) // unreferenced formal parameter
#endif

#ifndef PTHREAD_PERMIT_USE_BOOST
#include <atomic>
#ifdef _MSC_VER
#include <condition_variable>
#include <mutex>
namespace {
    struct timespec
    {
        time_t tv_sec;
        long tv_nsec;
    };
    inline std::chrono::time_point<std::chrono::system_clock> timespec_to_timepoint(const struct timespec *ts)
    {
        using namespace std::chrono;
        return time_point<system_clock>(duration_cast<system_clock::duration>(nanoseconds(ts->tv_sec * 1000000000ULL + ts->tv_nsec)));
    }
}
#endif
#else
#include "boost/atomic.hpp"
#ifdef _MSC_VER
#include "boost/thread.hpp"
namespace {
#ifndef BOOST_THREAD_PTHREAD_TIMESPEC_MSVC_DEFINED
    struct timespec
    {
        time_t tv_sec;
        long tv_nsec;
    };
#endif
    inline boost::chrono::time_point<boost::chrono::system_clock> timespec_to_timepoint(const struct timespec *ts)
    {
        using namespace boost::chrono;
        return time_point<system_clock>(duration_cast<system_clock::duration>(nanoseconds(ts->tv_sec * 1000000000ULL + ts->tv_nsec)));
    }
}
#endif
#endif

#ifdef __cplusplus
PTHREAD_PERMIT_CXX_NAMESPACE_BEGIN
#endif

/* We need inline */
#if !defined(__cplusplus) && !defined(inline) && (defined(_MSC_VER) || defined(__GNUC__) || defined(__clang__))
#define inline __inline
#endif

/* We need bool */
#ifdef __cplusplus
typedef bool _Bool;
#else
typedef unsigned char _Bool;
#endif

// Patch in the Boost C++11 atomics as if they were C11
#ifndef PTHREAD_PERMIT_USE_BOOST
using std::memory_order;
using std::memory_order_relaxed;
using std::memory_order_release;
using std::memory_order_acquire;
using std::memory_order_seq_cst;
typedef std::atomic<unsigned int> atomic_uint;
typedef std::atomic<unsigned int> atomic_uint_c11_compat;
inline void atomic_thread_fence(memory_order order) { std::atomic_thread_fence(order); }
#else
using boost::memory_order;
using boost::memory_order_relaxed;
using boost::memory_order_release;
using boost::memory_order_acquire;
using boost::memory_order_seq_cst;
typedef boost::atomic<unsigned int> atomic_uint;
typedef boost::atomic<unsigned int> atomic_uint_c11_compat;
inline void atomic_thread_fence(memory_order order) { boost::atomic_thread_fence(order); }
#endif
inline void atomic_init(volatile atomic_uint *o, unsigned int v) { o->store(v, memory_order_seq_cst); }
inline void atomic_store_explicit(volatile atomic_uint *o, unsigned int v, memory_order order) { o->store(v, order); }
inline unsigned int atomic_load_explicit(volatile atomic_uint *o, memory_order order) { return o->load(order); }
inline unsigned int atomic_exchange_explicit(volatile atomic_uint *o, unsigned int v, memory_order order) { return o->exchange(v, order); }
inline unsigned int atomic_compare_exchange_weak_explicit(volatile atomic_uint *o, unsigned int *expected, unsigned int v, memory_order success, memory_order failure) { return o->compare_exchange_weak(*expected, v, success, failure); }
inline unsigned int atomic_compare_exchange_strong_explicit(volatile atomic_uint *o, unsigned int *expected, unsigned int v, memory_order success, memory_order failure) { return o->compare_exchange_strong(*expected, v, success, failure); }
inline unsigned int atomic_fetch_add_explicit(volatile atomic_uint *o, unsigned int v, memory_order order) { return o->fetch_add(v, order); }

/****************** Declare and define just those bits of threads.h we need ***********************/
#ifdef _MSC_VER
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <intrin.h>
#include <process.h>
#endif

#if defined(__GNUC__) || defined(__clang__)
#ifdef _WIN32
#include <windows.h>
#endif
#include <sys/time.h>
#include <time.h>
#include <pthread.h>
#endif

enum mtx_types
{
  mtx_plain=0,
  mtx_recursive=1,
  mtx_timed=2
};
enum thrd_results
{
  thrd_success=0,
  thrd_timeout=ETIMEDOUT,
  thrd_busy=EBUSY,
  thrd_error=EINVAL,
  thrd_nomem=ENOMEM
};

inline int timespec_get(struct timespec *ts, int base)
{
#ifdef _MSC_VER
  FILETIME n;
  unsigned long long m;
  GetSystemTimeAsFileTime(&n); // GetSystemTimePreciseAsFileTime() is Win8 or later only :(
  m=((unsigned long long) n.dwHighDateTime<<32)|n.dwLowDateTime;
  m-=116444736000000000ULL; // 1601 to 1970
  ts->tv_sec=m/10000000;
  ts->tv_nsec=(m % 10000000) * 100;
  return base;
#else
#ifdef CLOCK_REALTIME
  clock_gettime(CLOCK_REALTIME, ts);
#else
  struct timeval tv;
  gettimeofday(&tv, 0);
  ts->tv_sec=tv.tv_sec;
  ts->tv_nsec=tv.tv_usec*1000;
#endif
  return base;
#endif
}
inline long long timespec_diff(const struct timespec *end, const struct timespec *start)
{
  long long ret=end->tv_sec-start->tv_sec;
  ret*=1000000000;
  ret+=end->tv_nsec-start->tv_nsec;
  return ret;
}

#ifdef _MSC_VER
/* The >= WinVista slim reader/writer locks are absolutely ideal for C11 threads emulation
as they are semantically identical, EXCEPT for the lack of a mtx_timedlock() equivalent
which I assume will need to turn up in some future Windows. For now, emulate C11 threading
primitives using C++ 11/Boost.
*/
#if 0
typedef CONDITION_VARIABLE cnd_t;
typedef SRWLOCK mtx_t;
typedef SRWLOCK pthread_mutex_t;

inline int cnd_broadcast(cnd_t *cond) { WakeAllConditionVariable(cond); return thrd_success; }
inline void cnd_destroy(cnd_t *cond) { }
inline int cnd_init(cnd_t *cond) { InitializeConditionVariable(cond); return thrd_success; }
inline int cnd_signal(cnd_t *cond) { WakeConditionVariable(cond); return thrd_success; }
inline int cnd_timedwait(cnd_t *PTHREAD_PERMIT_RESTRICT cond, mtx_t *PTHREAD_PERMIT_RESTRICT mtx, const struct timespec *PTHREAD_PERMIT_RESTRICT ts)
{
  struct timespec now;
  DWORD interval;
  timespec_get(&now, 1);
  interval=(DWORD)(timespec_diff(ts, &now)/1000000);
  return SleepConditionVariableSRW(cond, mtx, interval, 0) ? thrd_success : thrd_timeout;
}
inline int cnd_wait(cnd_t *cond, mtx_t *mtx) { return SleepConditionVariableSRW(cond, mtx, INFINITE, 0) ? thrd_success : thrd_timeout; }

inline void mtx_destroy(mtx_t *mtx) { }
inline int mtx_init(mtx_t *mtx, int type) { InitializeSRWLock(mtx); return thrd_success; }
inline int mtx_lock(mtx_t *mtx) { AcquireSRWLockExclusive(mtx); return thrd_success; }
//inline int mtx_timedlock(mtx_t *PTHREAD_PERMIT_RESTRICT mtx, const struct timespec *PTHREAD_PERMIT_RESTRICT ts);
inline int mtx_trylock(mtx_t *mtx) { return TryAcquireSRWLockExclusive(mtx) ? thrd_success : thrd_busy; }
inline int mtx_unlock(mtx_t *mtx) { ReleaseSRWLockExclusive(mtx); return thrd_success; }

#else

#ifndef PTHREAD_PERMIT_USE_BOOST
typedef std::condition_variable_any cnd_t;
typedef std::timed_mutex mtx_t;
typedef std::timed_mutex pthread_mutex_t;
typedef std::unique_lock<std::timed_mutex> unique_lock;
using std::adopt_lock;
using std::cv_status;
#else
typedef boost::condition_variable_any cnd_t;
typedef boost::timed_mutex mtx_t;
typedef boost::timed_mutex pthread_mutex_t;
typedef boost::unique_lock<boost::timed_mutex> unique_lock;
using boost::adopt_lock;
using boost::cv_status;
#endif

inline int cnd_broadcast(cnd_t *cond) { try { cond->notify_all(); return thrd_success; } catch(...) { return thrd_error; } }
inline void cnd_destroy(cnd_t *cond) { }
inline int cnd_init(cnd_t *cond) { return thrd_success; }
inline int cnd_signal(cnd_t *cond) { try { cond->notify_one(); return thrd_success; } catch(...) { return thrd_error; } }
inline int cnd_timedwait(cnd_t *PTHREAD_PERMIT_RESTRICT cond, mtx_t *PTHREAD_PERMIT_RESTRICT mtx, const struct timespec *PTHREAD_PERMIT_RESTRICT ts)
{
    try
    {
        unique_lock lock(*mtx, adopt_lock);
        try
        {
            int ret=cv_status::no_timeout==cond->wait_until(lock, timespec_to_timepoint(ts)) ? thrd_success : thrd_timeout;
            lock.release();
            return ret;
        }
        catch(...)
        {
            lock.release();
            throw;
        }
    }
    catch(...)
    {
        return thrd_error;
    }
}
inline int cnd_wait(cnd_t *cond, mtx_t *mtx)
{
    try
    {
        unique_lock lock(*mtx, adopt_lock);
        try
        {
            cond->wait(lock);
            lock.release();
            return thrd_success;
        }
        catch(...)
        {
            lock.release();
            throw;
        }
    }
    catch(...)
    {
        return thrd_error;
    }
}

inline void mtx_destroy(mtx_t *mtx) { }
inline int mtx_init(mtx_t *mtx, int type) { return thrd_success; }
inline int mtx_lock(mtx_t *mtx) { try { mtx->lock(); return thrd_success; } catch(...) { return thrd_error; } }
inline int mtx_timedlock(mtx_t *PTHREAD_PERMIT_RESTRICT mtx, const struct timespec *PTHREAD_PERMIT_RESTRICT ts) { try { return mtx->try_lock_until(timespec_to_timepoint(ts)) ? thrd_success : thrd_timeout; } catch(...) { return thrd_error; } }
inline int mtx_trylock(mtx_t *mtx) { try { return mtx->try_lock() ? thrd_success : thrd_busy; } catch(...) { return thrd_error; } }
inline int mtx_unlock(mtx_t *mtx) { try { mtx->unlock(); return thrd_success; } catch(...) { return thrd_error; } }
#endif

#else
typedef pthread_cond_t cnd_t;
typedef pthread_mutex_t mtx_t;

inline int cnd_broadcast(cnd_t *cond) { return pthread_cond_broadcast(cond); }
inline void cnd_destroy(cnd_t *cond) { pthread_cond_destroy(cond); }
inline int cnd_init(cnd_t *cond) { return pthread_cond_init((cond), NULL); }
inline int cnd_signal(cnd_t *cond) { return pthread_cond_signal(cond); }
inline int cnd_timedwait(cnd_t *PTHREAD_PERMIT_RESTRICT cond, mtx_t *PTHREAD_PERMIT_RESTRICT mtx, const struct timespec *PTHREAD_PERMIT_RESTRICT ts) { return pthread_cond_timedwait(cond, mtx, ts); }
inline int cnd_wait(cnd_t *cond, mtx_t *mtx) { return pthread_cond_wait(cond, mtx); }

inline void mtx_destroy(mtx_t *mtx) { pthread_mutex_destroy(mtx); }
inline int mtx_init(mtx_t *mtx, int) { return pthread_mutex_init((mtx), NULL); }
inline int mtx_lock(mtx_t *mtx) { return pthread_mutex_lock(mtx); }
inline int mtx_timedlock(mtx_t *PTHREAD_PERMIT_RESTRICT mtx, const struct timespec *PTHREAD_PERMIT_RESTRICT abs_timeout)
{
#ifndef __APPLE__
    return pthread_mutex_timedlock((mtx), (abs_timeout));
#else
    int pthread_rc;
    struct timespec remaining, slept, ts;

    remaining = *abs_timeout;
    while((pthread_rc = pthread_mutex_trylock(mtx)) == EBUSY) {
        ts.tv_sec = 0;
        ts.tv_nsec = (remaining.tv_sec > 0 ? 10000000
            : (remaining.tv_nsec > 10000000 ? 10000000 : remaining.tv_nsec));
        nanosleep(&ts, &slept);
        ts.tv_nsec -= slept.tv_nsec;
        if(ts.tv_nsec <= remaining.tv_nsec) {
            remaining.tv_nsec -= ts.tv_nsec;
        }
        else {
            remaining.tv_sec--;
            remaining.tv_nsec = (1000000 - (ts.tv_nsec - remaining.tv_nsec));
        }
        if(remaining.tv_sec < 0 || (!remaining.tv_sec && remaining.tv_nsec <= 0)) {
            return ETIMEDOUT;
        }
    }
    return pthread_rc;
#endif
}
//inline int mtx_trylock(mtx_t *mtx);
inline int mtx_unlock(mtx_t *mtx) { return pthread_mutex_unlock(mtx); }
#endif // _MSC_VER

#endif





/****************** Declare and define just those bits of threads.h we need ***********************/
#ifdef _MSC_VER
typedef int (*thrd_start_t)(void *);
typedef uintptr_t thrd_t;

inline int thrd_create(thrd_t *thr, thrd_start_t func, void *arg)
{
  *thr=_beginthread((void (*)(void *)) func, 0, arg);
  return thrd_success;
}
inline int thrd_sleep(const struct timespec *duration, const struct timespec *remaining)
{
  Sleep((DWORD)(duration->tv_sec*1000+duration->tv_nsec/1000000));
  return thrd_success;
}
inline void thrd_yield(void)
{
  Sleep(0);
}
#else
typedef int (*thrd_start_t)(void *);
typedef pthread_t thrd_t;

inline int thrd_create(thrd_t *thr, thrd_start_t func, void *arg)
{
  pthread_create(thr, NULL, (void *(*)(void *))func, arg);
  return thrd_success;
}
inline int thrd_sleep(const struct timespec *duration, struct timespec *remaining)
{
#ifdef _WIN32 // Mingw doesn't define a nanosleep in its libraries
  Sleep((DWORD)(duration->tv_sec*1000+duration->tv_nsec/1000000));
  return thrd_success;
#else
  return nanosleep(duration, remaining);
#endif
}
inline void thrd_yield(void)
{
  sched_yield();
}

#ifdef _MSC_VER
#pragma warning(pop)
#endif

#endif

#ifdef __cplusplus
PTHREAD_PERMIT_CXX_NAMESPACE_END
#endif

#endif

