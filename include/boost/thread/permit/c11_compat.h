/* c1x_compat.h
Declares and defines stuff from C11
(C) 2011-2014 Niall Douglas http://www.nedproductions.biz/


Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef C11_COMPAT_H
#define C11_COMPAT_H

#include <stdlib.h>
#include <errno.h>
#ifndef ETIMEDOUT
#define ETIMEDOUT       138
#endif

#if __STDC_VERSION__ < 199901L          /* not C99 or better */
#if !defined(PTHREAD_PERMIT_RESTRICT) && (defined(_MSC_VER) || defined(__GNUC__) || defined(__clang__))
#define PTHREAD_PERMIT_RESTRICT __restrict
#endif
#else
#define PTHREAD_PERMIT_RESTRICT restrict
#endif

#ifndef PTHREAD_PERMIT_RESTRICT
#define PTHREAD_PERMIT_RESTRICT
#endif

// If we have C11, just use that direct
#if __STDC_VERSION__ > 200000L

#include <stdatomic.h>
#include <threads.h>

#else // Need to fake C11 support using a mixture of C++ and OS calls

#include "boost/atomic.hpp"

#ifdef __cplusplus
PTHREAD_PERMIT_CXX_NAMESPACE {
#endif

/* We need inline */
#if !defined(__cplusplus) && !defined(inline) && (defined(_MSC_VER) || defined(__GNUC__) || defined(__clang__))
#define inline __inline
#endif

/* We need bool */
#ifdef __cplusplus
typedef bool _Bool;
#else
typedef unsigned char _Bool;
#endif

// Patch in the Boost C++11 atomics as if they were C11
using boost::memory_order;
using boost::memory_order_relaxed;
using boost::memory_order_release;
using boost::memory_order_acquire;
using boost::memory_order_seq_cst;
typedef boost::atomic<unsigned int> atomic_uint;
inline void atomic_init(volatile atomic_uint *o, unsigned int v) { o->store(v, memory_order_seq_cst); }
inline void atomic_thread_fence(memory_order order) { boost::atomic_thread_fence(order); }
inline void atomic_store_explicit(volatile atomic_uint *o, unsigned int v, memory_order order) { o->store(v, order); }
inline unsigned int atomic_load_explicit(volatile atomic_uint *o, memory_order order) { return o->load(order); }
inline unsigned int atomic_exchange_explicit(volatile atomic_uint *o, unsigned int v, memory_order order) { return o->exchange(v, order); }
inline unsigned int atomic_compare_exchange_weak_explicit(volatile atomic_uint *o, unsigned int *expected, unsigned int v, memory_order success, memory_order failure) { return o->compare_exchange_weak(*expected, v, success, failure); }
inline unsigned int atomic_compare_exchange_strong_explicit(volatile atomic_uint *o, unsigned int *expected, unsigned int v, memory_order success, memory_order failure) { return o->compare_exchange_strong(*expected, v, success, failure); }
inline unsigned int atomic_fetch_add_explicit(volatile atomic_uint *o, unsigned int v, memory_order order) { return o->fetch_add(v, order); }

/****************** Declare and define just those bits of threads.h we need ***********************/
#ifdef _MSC_VER
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <intrin.h>
#include <process.h>
#endif

#if defined(__GNUC__) || defined(__clang__)
#ifdef _WIN32
#include <windows.h>
#endif
#include <sys/time.h>
#include <time.h>
#include <pthread.h>
#endif

enum mtx_types
{
  mtx_plain=0,
  mtx_recursive=1,
  mtx_timed=2
};
enum thrd_results
{
  thrd_success=0,
  thrd_timeout=ETIMEDOUT,
  thrd_busy=EBUSY,
  thrd_error=EINVAL,
  thrd_nomem=ENOMEM
};

#ifdef _MSC_VER
struct timespec
{
  time_t tv_sec;
  long tv_nsec;
};

typedef CONDITION_VARIABLE cnd_t;
typedef SRWLOCK mtx_t;
typedef SRWLOCK pthread_mutex_t;
#else
typedef pthread_cond_t cnd_t;
typedef pthread_mutex_t mtx_t;
#endif

#define TIME_UTC 1
inline int timespec_get(struct timespec *ts, int base)
{
#ifdef _MSC_VER
  static LARGE_INTEGER ticksPerSec;
  static double scalefactor;
  LARGE_INTEGER val;
  if(!scalefactor)
  {
	if(QueryPerformanceFrequency(&ticksPerSec))
		scalefactor=ticksPerSec.QuadPart/1000000000.0;
	else
		scalefactor=1;
  }
  if(!QueryPerformanceCounter(&val))
  {
    DWORD now=GetTickCount();
    ts->tv_sec=now/1000;
    ts->tv_nsec=(now%1000)*1000000;
    return base;
  }
  {
    unsigned long long now=(unsigned long long)(val.QuadPart/scalefactor);
    ts->tv_sec=now/1000000000;
    ts->tv_nsec=now%1000000000;
  }
  return base;
#else
#ifdef CLOCK_MONOTONIC
  clock_gettime(CLOCK_MONOTONIC, ts);
#else
  struct timeval tv;
  gettimeofday(&tv, 0);
  ts->tv_sec=tv.tv_sec;
  ts->tv_nsec=tv.tv_usec*1000;
#endif
  return base;
#endif
}
inline long long timespec_diff(const struct timespec *end, const struct timespec *start)
{
  long long ret=end->tv_sec-start->tv_sec;
  ret*=1000000000;
  ret+=end->tv_nsec-start->tv_nsec;
  return ret;
}

#ifdef _MSC_VER
inline int cnd_broadcast(cnd_t *cond) { WakeAllConditionVariable(cond); return thrd_success; }
inline void cnd_destroy(cnd_t *cond) { }
inline int cnd_init(cnd_t *cond) { InitializeConditionVariable(cond); return thrd_success; }
inline int cnd_signal(cnd_t *cond) { WakeConditionVariable(cond); return thrd_success; }
inline int cnd_timedwait(cnd_t *PTHREAD_PERMIT_RESTRICT cond, mtx_t *PTHREAD_PERMIT_RESTRICT mtx, const struct timespec *PTHREAD_PERMIT_RESTRICT ts)
{
  struct timespec now;
  DWORD interval;
  timespec_get(&now, TIME_UTC);
  interval=(DWORD)(timespec_diff(ts, &now)/1000000);
  return SleepConditionVariableSRW(cond, mtx, interval, 0) ? thrd_success : thrd_timeout;
}
inline int cnd_wait(cnd_t *cond, mtx_t *mtx) { return SleepConditionVariableSRW(cond, mtx, INFINITE, 0) ? thrd_success : thrd_timeout; }

inline void mtx_destroy(mtx_t *mtx) { }
inline int mtx_init(mtx_t *mtx, int type) { InitializeSRWLock(mtx); return thrd_success; }
inline int mtx_lock(mtx_t *mtx) { AcquireSRWLockExclusive(mtx); return thrd_success; }
//inline int mtx_timedlock(mtx_t *PTHREAD_PERMIT_RESTRICT mtx, const struct timespec *PTHREAD_PERMIT_RESTRICT ts);
inline int mtx_trylock(mtx_t *mtx) { return TryAcquireSRWLockExclusive(mtx) ? thrd_success : thrd_busy; }
inline int mtx_unlock(mtx_t *mtx) { ReleaseSRWLockExclusive(mtx); return thrd_success; }
#else
inline int cnd_broadcast(cnd_t *cond) { return pthread_cond_broadcast(cond); }
inline void cnd_destroy(cnd_t *cond) { pthread_cond_destroy(cond); }
inline int cnd_init(cnd_t *cond) { return pthread_cond_init((cond), NULL); }
inline int cnd_signal(cnd_t *cond) { return pthread_cond_signal(cond); }
inline int cnd_timedwait(cnd_t *PTHREAD_PERMIT_RESTRICT cond, mtx_t *PTHREAD_PERMIT_RESTRICT mtx, const struct timespec *PTHREAD_PERMIT_RESTRICT ts) { return pthread_cond_timedwait(cond, mtx, ts); }
inline int cnd_wait(cnd_t *cond, mtx_t *mtx) { return pthread_cond_wait(cond, mtx); }

inline void mtx_destroy(mtx_t *mtx) { pthread_mutex_destroy(mtx); }
inline int mtx_init(mtx_t *mtx, int type) { return pthread_mutex_init((mtx), NULL); }
inline int mtx_lock(mtx_t *mtx) { return pthread_mutex_lock(mtx); }
//inline int mtx_timedlock(mtx_t *PTHREAD_PERMIT_RESTRICT mtx, const struct timespec *PTHREAD_PERMIT_RESTRICT ts);
//inline int mtx_trylock(mtx_t *mtx);
inline int mtx_unlock(mtx_t *mtx) { return pthread_mutex_unlock(mtx); }
#endif // _MSC_VER

#endif





/****************** Declare and define just those bits of threads.h we need ***********************/
#ifdef _MSC_VER
typedef int (*thrd_start_t)(void *);
typedef uintptr_t thrd_t;

inline int thrd_create(thrd_t *thr, thrd_start_t func, void *arg)
{
  *thr=_beginthread((void (*)(void *)) func, 0, arg);
  return thrd_success;
}
inline int thrd_sleep(const struct timespec *duration, const struct timespec *remaining)
{
  Sleep((DWORD)(duration->tv_sec*1000+duration->tv_nsec/1000000));
  return thrd_success;
}
inline void thrd_yield(void)
{
  Sleep(0);
}
#else
typedef int (*thrd_start_t)(void *);
typedef pthread_t thrd_t;

inline int thrd_create(thrd_t *thr, thrd_start_t func, void *arg)
{
  pthread_create(thr, NULL, (void *(*)(void *))func, arg);
  return thrd_success;
}
inline int thrd_sleep(const struct timespec *duration, struct timespec *remaining)
{
#ifdef _WIN32 // Mingw doesn't define a nanosleep in its libraries
  Sleep((DWORD)(duration->tv_sec*1000+duration->tv_nsec/1000000));
  return thrd_success;
#else
  return nanosleep(duration, remaining);
#endif
}
inline void thrd_yield(void)
{
  sched_yield();
}
#endif

#ifdef __cplusplus
}
#endif

#endif

