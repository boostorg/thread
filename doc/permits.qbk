[/
  (C) Copyright 2007-11 Anthony Williams.
  (C) Copyright 2011-12 Vicente J. Botet Escriba.
  (C) Copyright 2014 Niall Douglas
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[section:permit_ref Permits -- EXTENSION]

[heading Synopsis]

  namespace boost 
  {
    enum class cv_status;
    {
      no_timeout,
      timeout
    };
    template<bool consuming=true> class permit;
    template<bool consuming=true> class permit_any;
    typedef permit<true> permit_c;
    typedef permit_any<true> permit_c_any;
    typedef permit<false> permit_nc;
    typedef permit_any<false> permit_nc_any;
  }

The classes `permit<>` and `permit_any<>` provide a [*safe] mechanism for one
thread to wait for notification from another thread that something has
happened -- one thread gives ['permission] to another thread to continue
execution. Unlike condition variables where it is very
easy to unintentionally introduce lost and spurious wakeup race conditions,
the permit object provides a number of strong guarantees which make it very
hard to use in a racy way. The permit implementations follow an identical
API to `condition_variable` and `condition_variable_any`, thus making a
find and replace solution to fixing up legacy C++ codebases straightforward.

Permits come in two variants, consuming and non-consuming. There is [*always]
a one-to-one relationship between the granting of a permit and the receiving
of that permit, the only difference with the non-consuming variant is that
the permit is automatically regranted as soon as it is consumed. This leads
to the only API difference to condition variables: `permit<consuming=true>`
provides `notify_one()` but not `notify_all()`, whilst `permit<consuming=false>`
provides `notify_all()` but not `notify_one()`. When deciding to substitute
permits for condition variables, you will need to decide carefully which
kind of permit is the correct substitute.

The strong guarantees given by permit objects are as follows:

# You will never see spurious wakeups from a permit object -- waits never,
ever return successfully unless a permit has been granted or the permit
object was destroyed.

# You will never see lost wakeups from a permit object -- if there are
no waiting threads at the point of permit grant, the permit remains
granted until some waiting thread consumes the permit.

# For the non-consuming permit, exactly those threads currently waiting
at the point of grant will be released, no more, no less. This solves the
producer-consumer problem often seen in naive use of semaphores.

# You are allowed to destroy a permit being waited upon in other threads
which when tried with condition variables produces undefined behaviour
(and sometimes memory corruption).

# Additionally, the following very common pattern is safe, which it would not be
with condition variables:

    {
        boost::permit_c done;
        boost::mutex lock;
        int result=0;
        boost::lock_guard<decltype(lock)> guard(lock);
        boost::thread([&]{
            {
                boost::lock_guard<decltype(lock)> guard2(lock);
                result=78;
            }
            done.notify_one();
        });
        while(!result)
            done.wait(guard);
        // missing thread join!
    }
    
 The problem here is that the notify can cause the permit object to be
 destroyed before the notify has exited -- which if tried with condition
 variables will almost certainly produce memory corruption. With permits
 this pattern is allowed: all grants being executed at the time of destruction
 are safe.

[section:condition_variable Class `condition_variable`]

    //#include <boost/thread/condition_variable.hpp>

    namespace boost
    {
        class condition_variable
        {
        public:
            condition_variable();
            ~condition_variable();

            void notify_one() noexcept;
            void notify_all() noexcept;

            void wait(boost::unique_lock<boost::mutex>& lock);

            template<typename predicate_type>
            void wait(boost::unique_lock<boost::mutex>& lock,predicate_type predicate);

            template <class Clock, class Duration>
            typename cv_status::type
            wait_until(
                unique_lock<mutex>& lock,
                const chrono::time_point<Clock, Duration>& t);

            template <class Clock, class Duration, class Predicate>
            bool
            wait_until(
                unique_lock<mutex>& lock,
                const chrono::time_point<Clock, Duration>& t,
                Predicate pred);

            template <class Rep, class Period>
            typename cv_status::type
            wait_for(
                unique_lock<mutex>& lock,
                const chrono::duration<Rep, Period>& d);

            template <class Rep, class Period, class Predicate>
            bool
            wait_for(
                unique_lock<mutex>& lock,
                const chrono::duration<Rep, Period>& d,
                Predicate pred);

        #if defined BOOST_THREAD_USES_DATETIME
            bool timed_wait(boost::unique_lock<boost::mutex>& lock,boost::system_time const& abs_time);
            template<typename duration_type>
            bool timed_wait(boost::unique_lock<boost::mutex>& lock,duration_type const& rel_time);
            template<typename predicate_type>
            bool timed_wait(boost::unique_lock<boost::mutex>& lock,boost::system_time const& abs_time,predicate_type predicate);
            template<typename duration_type,typename predicate_type>
            bool timed_wait(boost::unique_lock<boost::mutex>& lock,duration_type const& rel_time,predicate_type predicate);
            bool timed_wait(boost::unique_lock<boost::mutex>& lock,boost::xtime const& abs_time);

            template<typename predicate_type>
            bool timed_wait(boost::unique_lock<boost::mutex>& lock,boost::xtime const& abs_time,predicate_type predicate);
        #endif

        };
    }

[section:constructor `condition_variable()`]

[variablelist

[[Effects:] [Constructs an object of class `condition_variable`.]]

[[Throws:] [__thread_resource_error__ if an error occurs.]]

]

[endsect]

[section:destructor `~condition_variable()`]

[variablelist

[[Precondition:] [All threads waiting on `*this` have been notified by a call to
`notify_one` or `notify_all` (though the respective calls to `wait` or
`timed_wait` need not have returned).]]

[[Effects:] [Destroys the object.]]

[[Throws:] [Nothing.]]

]

[endsect]

[section:notify_one `void notify_one()`]

[variablelist

[[Effects:] [If any threads are currently __blocked__ waiting on `*this` in a call
to `wait` or `timed_wait`, unblocks one of those threads.]]

[[Throws:] [Nothing.]]

]

[endsect]

[section:notify_all `void notify_all()`]

[variablelist

[[Effects:] [If any threads are currently __blocked__ waiting on `*this` in a call
to `wait` or `timed_wait`, unblocks all of those threads.]]

[[Throws:] [Nothing.]]

]

[endsect]

[section:wait `void wait(boost::unique_lock<boost::mutex>& lock)`]

[variablelist

[[Precondition:] [`lock` is locked by the current thread, and either no other
thread is currently waiting on `*this`, or the execution of the `mutex()` member
function on the `lock` objects supplied in the calls to `wait` or `timed_wait`
in all the threads currently waiting on `*this` would return the same value as
`lock->mutex()` for this call to `wait`.]]

[[Effects:] [Atomically call `lock.unlock()` and blocks the current thread. The
thread will unblock when notified by a call to `this->notify_one()` or
`this->notify_all()`, or spuriously. When the thread is unblocked (for whatever
reason), the lock is reacquired by invoking `lock.lock()` before the call to
`wait` returns. The lock is also reacquired by invoking `lock.lock()` if the
function exits with an exception.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[endsect]

[section:wait_predicate `template<typename predicate_type> void wait(boost::unique_lock<boost::mutex>& lock, predicate_type pred)`]

[variablelist

[[Effects:] [As-if ``
while(!pred())
{
    wait(lock);
}
``]]

]

[endsect]

[section:timed_wait `bool timed_wait(boost::unique_lock<boost::mutex>& lock,boost::system_time const& abs_time)`]

[variablelist

[[Precondition:] [`lock` is locked by the current thread, and either no other
thread is currently waiting on `*this`, or the execution of the `mutex()` member
function on the `lock` objects supplied in the calls to `wait` or `timed_wait`
in all the threads currently waiting on `*this` would return the same value as
`lock->mutex()` for this call to `wait`.]]

[[Effects:] [Atomically call `lock.unlock()` and blocks the current thread. The
thread will unblock when notified by a call to `this->notify_one()` or
`this->notify_all()`, when the time as reported by `boost::get_system_time()`
would be equal to or later than the specified `abs_time`, or spuriously. When
the thread is unblocked (for whatever reason), the lock is reacquired by
invoking `lock.lock()` before the call to `wait` returns. The lock is also
reacquired by invoking `lock.lock()` if the function exits with an exception.]]

[[Returns:] [`false` if the call is returning because the time specified by
`abs_time` was reached, `true` otherwise.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[endsect]

[section:timed_wait_rel `template<typename duration_type> bool timed_wait(boost::unique_lock<boost::mutex>& lock,duration_type const& rel_time)`]

[variablelist

[[Precondition:] [`lock` is locked by the current thread, and either no other
thread is currently waiting on `*this`, or the execution of the `mutex()` member
function on the `lock` objects supplied in the calls to `wait` or `timed_wait`
in all the threads currently waiting on `*this` would return the same value as
`lock->mutex()` for this call to `wait`.]]

[[Effects:] [Atomically call `lock.unlock()` and blocks the current thread. The
thread will unblock when notified by a call to `this->notify_one()` or
`this->notify_all()`, after the period of time indicated by the `rel_time`
argument has elapsed, or spuriously. When the thread is unblocked (for whatever
reason), the lock is reacquired by invoking `lock.lock()` before the call to
`wait` returns. The lock is also reacquired by invoking `lock.lock()` if the
function exits with an exception.]]

[[Returns:] [`false` if the call is returning because the time period specified
by `rel_time` has elapsed, `true` otherwise.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[note The duration overload of timed_wait is difficult to use correctly. The overload taking a predicate should be preferred in most cases.]

[endsect]

[section:timed_wait_predicate `template<typename predicate_type> bool timed_wait(boost::unique_lock<boost::mutex>& lock, boost::system_time const& abs_time, predicate_type pred)`]

[variablelist

[[Effects:] [As-if ``
while(!pred())
{
    if(!timed_wait(lock,abs_time))
    {
        return pred();
    }
}
return true;
``]]

]

[endsect]


[section:wait_until `template <class Clock, class Duration> cv_status wait_until(boost::unique_lock<boost::mutex>& lock, const chrono::time_point<Clock, Duration>& abs_time)`]

[variablelist

[[Precondition:] [`lock` is locked by the current thread, and either no other
thread is currently waiting on `*this`, or the execution of the `mutex()` member
function on the `lock` objects supplied in the calls to `wait` or `wait_for` or `wait_until`
in all the threads currently waiting on `*this` would return the same value as
`lock->mutex()` for this call to `wait`.]]

[[Effects:] [Atomically call `lock.unlock()` and blocks the current thread. The
thread will unblock when notified by a call to `this->notify_one()` or
`this->notify_all()`, when the time as reported by `Clock::now()`
would be equal to or later than the specified `abs_time`, or spuriously. When
the thread is unblocked (for whatever reason), the lock is reacquired by
invoking `lock.lock()` before the call to `wait` returns. The lock is also
reacquired by invoking `lock.lock()` if the function exits with an exception.]]

[[Returns:] [`cv_status::timeout` if the call is returning because the time specified by
`abs_time` was reached, `cv_status::no_timeout` otherwise.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[endsect]

[section:wait_for `template <class Rep, class Period> cv_status wait_for(boost::unique_lock<boost::mutex>& lock, const chrono::duration<Rep, Period>& rel_time)`]


[variablelist

[[Precondition:] [`lock` is locked by the current thread, and either no other
thread is currently waiting on `*this`, or the execution of the `mutex()` member
function on the `lock` objects supplied in the calls to `wait` or `wait_until` or `wait_for`
in all the threads currently waiting on `*this` would return the same value as
`lock->mutex()` for this call to `wait`.]]

[[Effects:] [Atomically call `lock.unlock()` and blocks the current thread. The
thread will unblock when notified by a call to `this->notify_one()` or
`this->notify_all()`, after the period of time indicated by the `rel_time`
argument has elapsed, or spuriously. When the thread is unblocked (for whatever
reason), the lock is reacquired by invoking `lock.lock()` before the call to
`wait` returns. The lock is also reacquired by invoking `lock.lock()` if the
function exits with an exception.]]

[[Returns:] [`cv_status::timeout ` if the call is returning because the time period specified
by `rel_time` has elapsed, `cv_status::no_timeout ` otherwise.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[note The duration overload of timed_wait is difficult to use correctly. The overload taking a predicate should be preferred in most cases.]

[endsect]

[section:wait_until_predicate `template <class Clock, class Duration, class Predicate> bool wait_until(boost::unique_lock<boost::mutex>& lock, const chrono::time_point<Clock, Duration>& abs_time, Predicate pred)`]


[variablelist

[[Effects:] [As-if ``
while(!pred())
{
    if(!wait_until(lock,abs_time))
    {
        return pred();
    }
}
return true;
``]]

]

[endsect]

[section:wait_for_predicate `template <class Rep, class Period, class Predicate> bool wait_for(boost::unique_lock<boost::mutex>& lock, const chrono::duration<Rep, Period>& rel_time, Predicate pred)`]


[variablelist

[[Effects:] [As-if ``
return wait_until(lock, chrono::steady_clock::now() + d, boost::move(pred));
``]]

]

[endsect]




[endsect]

[section:condition_variable_any Class `condition_variable_any`]

    //#include <boost/thread/condition_variable.hpp>

    namespace boost
    {
        class condition_variable_any
        {
        public:
            condition_variable_any();
            ~condition_variable_any();

            void notify_one();
            void notify_all();

            template<typename lock_type>
            void wait(lock_type& lock);

            template<typename lock_type,typename predicate_type>
            void wait(lock_type& lock,predicate_type predicate);

            template <class lock_type, class Clock, class Duration>
            cv_status wait_until(
                lock_type& lock,
                const chrono::time_point<Clock, Duration>& t);

            template <class lock_type, class Clock, class Duration, class Predicate>
            bool wait_until(
                lock_type& lock,
                const chrono::time_point<Clock, Duration>& t,
                Predicate pred);


            template <class lock_type, class Rep, class Period>
            cv_status wait_for(
                lock_type& lock,
                const chrono::duration<Rep, Period>& d);

            template <class lock_type, class Rep, class Period, class Predicate>
            bool wait_for(
                lock_type& lock,
                const chrono::duration<Rep, Period>& d,
                Predicate pred);

        #if defined BOOST_THREAD_USES_DATETIME
            template<typename lock_type>
            bool timed_wait(lock_type& lock,boost::system_time const& abs_time);
            template<typename lock_type,typename duration_type>
            bool timed_wait(lock_type& lock,duration_type const& rel_time);
            template<typename lock_type,typename predicate_type>
            bool timed_wait(lock_type& lock,boost::system_time const& abs_time,predicate_type predicate);
            template<typename lock_type,typename duration_type,typename predicate_type>
            bool timed_wait(lock_type& lock,duration_type const& rel_time,predicate_type predicate);
            template<typename lock_type>
            bool timed_wait(lock_type>& lock,boost::xtime const& abs_time);
            template<typename lock_type,typename predicate_type>
            bool timed_wait(lock_type& lock,boost::xtime const& abs_time,predicate_type predicate);
        #endif
        };
    }

[section:constructor `condition_variable_any()`]

[variablelist

[[Effects:] [Constructs an object of class `condition_variable_any`.]]

[[Throws:] [__thread_resource_error__ if an error occurs.]]

]

[endsect]

[section:destructor `~condition_variable_any()`]

[variablelist

[[Precondition:] [All threads waiting on `*this` have been notified by a call to
`notify_one` or `notify_all` (though the respective calls to `wait` or
`timed_wait` need not have returned).]]

[[Effects:] [Destroys the object.]]

[[Throws:] [Nothing.]]

]

[endsect]

[section:notify_one `void notify_one()`]

[variablelist

[[Effects:] [If any threads are currently __blocked__ waiting on `*this` in a call
to `wait` or `timed_wait`, unblocks one of those threads.]]

[[Throws:] [Nothing.]]

]

[endsect]

[section:notify_all `void notify_all()`]

[variablelist

[[Effects:] [If any threads are currently __blocked__ waiting on `*this` in a call
to `wait` or `timed_wait`, unblocks all of those threads.]]

[[Throws:] [Nothing.]]

]

[endsect]

[section:wait `template<typename lock_type> void wait(lock_type& lock)`]

[variablelist

[[Effects:] [Atomically call `lock.unlock()` and blocks the current thread. The
thread will unblock when notified by a call to `this->notify_one()` or
`this->notify_all()`, or spuriously. When the thread is unblocked (for whatever
reason), the lock is reacquired by invoking `lock.lock()` before the call to
`wait` returns. The lock is also reacquired by invoking `lock.lock()` if the
function exits with an exception.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[endsect]

[section:wait_predicate `template<typename lock_type,typename predicate_type> void wait(lock_type& lock, predicate_type pred)`]

[variablelist

[[Effects:] [As-if ``
while(!pred())
{
    wait(lock);
}
``]]

]

[endsect]

[section:timed_wait `template<typename lock_type> bool timed_wait(lock_type& lock,boost::system_time const& abs_time)`]

[variablelist

[[Effects:] [Atomically call `lock.unlock()` and blocks the current thread. The
thread will unblock when notified by a call to `this->notify_one()` or
`this->notify_all()`, when the time as reported by `boost::get_system_time()`
would be equal to or later than the specified `abs_time`, or spuriously. When
the thread is unblocked (for whatever reason), the lock is reacquired by
invoking `lock.lock()` before the call to `wait` returns. The lock is also
reacquired by invoking `lock.lock()` if the function exits with an exception.]]

[[Returns:] [`false` if the call is returning because the time specified by
`abs_time` was reached, `true` otherwise.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[endsect]

[section:timed_wait_rel `template<typename lock_type,typename duration_type> bool timed_wait(lock_type& lock,duration_type const& rel_time)`]

[variablelist

[[Effects:] [Atomically call `lock.unlock()` and blocks the current thread. The
thread will unblock when notified by a call to `this->notify_one()` or
`this->notify_all()`, after the period of time indicated by the `rel_time`
argument has elapsed, or spuriously. When the thread is unblocked (for whatever
reason), the lock is reacquired by invoking `lock.lock()` before the call to
`wait` returns. The lock is also reacquired by invoking `lock.lock()` if the
function exits with an exception.]]

[[Returns:] [`false` if the call is returning because the time period specified
by `rel_time` has elapsed, `true` otherwise.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[note The duration overload of timed_wait is difficult to use correctly. The overload taking a predicate should be preferred in most cases.]

[endsect]

[section:timed_wait_predicate `template<typename lock_type,typename predicate_type> bool timed_wait(lock_type& lock, boost::system_time const& abs_time, predicate_type pred)`]

[variablelist

[[Effects:] [As-if ``
while(!pred())
{
    if(!timed_wait(lock,abs_time))
    {
        return pred();
    }
}
return true;
``]]

]

[endsect]

[section:wait_until `template <class lock_type, class Clock, class Duration> cv_status wait_until(lock_type& lock, const chrono::time_point<Clock, Duration>& abs_time)`]

[variablelist

[[Effects:] [Atomically call `lock.unlock()` and blocks the current thread. The
thread will unblock when notified by a call to `this->notify_one()` or
`this->notify_all()`, when the time as reported by `Clock::now()`
would be equal to or later than the specified `abs_time`, or spuriously. When
the thread is unblocked (for whatever reason), the lock is reacquired by
invoking `lock.lock()` before the call to `wait` returns. The lock is also
reacquired by invoking `lock.lock()` if the function exits with an exception.]]

[[Returns:] [`cv_status::timeout` if the call is returning because the time specified by
`abs_time` was reached, `cv_status::no_timeout` otherwise.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[endsect]

[section:wait_for `template <class lock_type, class Rep, class Period> cv_status wait_for(lock_type& lock, const chrono::duration<Rep, Period>& rel_time)`]

[variablelist

[[Effects:] [Atomically call `lock.unlock()` and blocks the current thread. The
thread will unblock when notified by a call to `this->notify_one()` or
`this->notify_all()`, after the period of time indicated by the `rel_time`
argument has elapsed, or spuriously. When the thread is unblocked (for whatever
reason), the lock is reacquired by invoking `lock.lock()` before the call to
`wait` returns. The lock is also reacquired by invoking `lock.lock()` if the
function exits with an exception.]]

[[Returns:] [`cv_status::timeout` if the call is returning because the time specified by
`abs_time` was reached, `cv_status::no_timeout` otherwise.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[note The duration overload of timed_wait is difficult to use correctly. The overload taking a predicate should be preferred in most cases.]

[endsect]

[section:wait_until_predicate `template <class lock_type, class Clock, class Duration, class Predicate> bool wait_until(lock_type& lock, const chrono::time_point<Clock, Duration>& abs_time, Predicate pred)`]

[variablelist

[[Effects:] [As-if ``
while(!pred())
{
    if(!__cvany_wait_until(lock,abs_time))
    {
        return pred();
    }
}
return true;
``]]

]

[endsect]

[section:wait_for_predicate `template <class lock_type, class Rep, class Period, class Predicate> bool wait_for(lock_type& lock, const chrono::duration<Rep, Period>& rel_time, Predicate pred)`]

[variablelist

[[Effects:] [As-if ``
return wait_until(lock, chrono::steady_clock::now() + d, boost::move(pred));
``]]

]

[endsect]

[endsect]

[section:condition Typedef `condition` DEPRECATED V3]

  // #include <boost/thread/condition.hpp>
  namespace boost 
  {

    typedef condition_variable_any condition;

  }

The typedef `condition` is provided for backwards compatibility with previous boost releases.

[endsect]


[section:notify_all_at_thread_exit Non-member Function `notify_all_at_thread_exit`()]

  // #include <boost/thread/condition_variable.hpp>

  namespace boost
  {
    void notify_all_at_thread_exit(condition_variable& cond, unique_lock<mutex> lk);
  }

[variablelist

[[Requires:] [`lk` is locked by the calling thread and either no other thread is waiting on `cond`, or `lk.mutex()` returns the same value for each of the lock arguments supplied by all concurrently waiting (via `wait`, `wait_for`, or `wait_until`) threads.]]
[[Effects:] [transfers ownership of the lock associated with `lk` into internal storage and schedules `cond` to be notified when the current thread exits, after all objects of thread storage duration associated with the current thread have been destroyed. This notification shall be as if

``
  lk.unlock();
  cond.notify_all();
``

]]

]

[/
[[Synchronization:] [The call to notify_all_at_thread_exit and the completion of the destructors for all the current thread’s variables of thread storage duration synchronize with (1.10) calls to functions waiting on cond.
]]
[[Note:] [The supplied lock will be held until the thread exits, and care must be taken to ensure that this does not cause deadlock due to lock ordering issues. After calling notify_all_at_thread_exit it is recommended that the thread should be exited as soon as possible, and that no blocking or time-consuming tasks are run on that thread.
]]
[[Note:] [It is the user’s responsibility to ensure that waiting threads do not erroneously assume that the thread has finished if they experience spurious wakeups. This typically requires that the condition being waited for is satisfied while holding the lock on lk, and that this lock is not released and reacquired prior to calling notify_all_at_thread_exit.
]]
]

[endsect]

[endsect]
