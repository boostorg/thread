[/
  (C) Copyright 2014 Niall Douglas
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[section:permit_ref Permits -- EXTENSION]

(C) 2011-2014 Niall Douglas

[heading Synopsis]

  namespace boost 
  {
    enum class cv_status;
    {
      no_timeout,
      timeout
    };
    template<bool consuming=true> class permit;
    template<bool consuming=true> class permit_any;
    typedef permit<true> permit_c;
    typedef permit_any<true> permit_c_any;
    typedef permit<false> permit_nc;
    typedef permit_any<false> permit_nc_any;
  }

The classes `permit<>` and `permit_any<>` provide a [*safe] mechanism for one
thread to wait for notification from another thread that something has
happened -- one thread gives a ['one time permission] (a permit) to another
thread to continue execution. Unlike condition variables where it is very
easy to unintentionally introduce lost and spurious wakeup race conditions,
the permit object provides a number of strong guarantees which make it very
hard to use in a racy way. The permit implementations follow an identical
API to `condition_variable` and `condition_variable_any`, thus making a
find and replace solution to fixing up legacy C++ codebases straightforward.

Permits come in two variants, consuming and non-consuming. There is [*always]
a one-to-one relationship between the granting of a permit and the receiving
of that permit, the only difference with the non-consuming variant is that
the permit is automatically regranted as soon as it is consumed. This leads
to the only API difference to condition variables: `permit<consuming=true>`
provides `notify_one()` but not `notify_all()`, whilst `permit<consuming=false>`
provides `notify_all()` but not `notify_one()`. When deciding to substitute
permits for condition variables, you will need to decide carefully which
kind of permit is the correct substitute.

The strong guarantees given by permit objects are as follows:

# You will never see spurious wakeups from a permit object -- waits never,
ever return successfully unless a permit has been granted or the permit
object was destroyed. This means you don't need to do any wait predicate checking
with permits (though they are supported anyway for API compatibility with
condition variables).

# You will never see lost wakeups from a permit object -- if there are
no waiting threads at the point of permit grant, the permit remains
granted until ['some] waiting thread consumes the permit. This means you don't
need to do any notify predicate checking with permits either.

# For the non-consuming permit, [*exactly] those threads currently waiting
at the point of grant will be released, no more, no less. This solves the
producer-consumer problem often seen in naive use of semaphores.

# Multiple threads both granting and waiting simultaneously works as expected,
which allows replacement of many semaphore based solutions (semaphores can
have unhelpful differences of implementation across operating systems).

# You are allowed to destroy a permit being actively waited upon in other threads
which when tried with condition variables produces undefined behaviour
(and sometimes memory corruption).

# Additionally, the following common pattern is safe, which it would not be
with condition variables:

    {
        boost::permit_c done;
        boost::mutex lock;
        int result=0;
        boost::lock_guard<decltype(lock)> guard(lock);
        boost::thread([&]{
            boost::lock_guard<decltype(lock)> guard2(lock);
            result=78;
            done.notify_one();
        });
        done.wait(guard); // don't need predicate checks with permits
        // missing thread join!
    }
    
 The problem here is that the notify can cause the permit object to be
 destroyed before the notify has exited -- which if tried with condition
 variables will almost certainly produce memory corruption. With permits
 this pattern is allowed: all grants being executed at the time of destruction
 are safe, though for obvious reasons only the grant which woke the thread
 which destroyed the permit is guaranteed to not return an error.

[warning Be careful of directly using condition variables in your code!]

Surprisingly little code which directly uses condition variables is completely problem
free -- condition variables are a threading ['primitive] for a reason, but
unlike the other threading primitives they are particularly easy to write
faulty code against. A very good sign of incorrect usage is when a wait
is not surrounded with a loop testing a predicate as condition variables
are prone to spurious wakeups, but even with judicious use of predicates
there are also problems with ["lost wakeups] in most code directly using
condition variables.

As a quick survey of the very subtle dragons which live here, let
us look at a common code pattern directly using condition variables:

    boost::condition_variable done;
    int result=0;
    boost::thread([&]{
        result=78;
        done.notify_one();
    });
    boost::mutex lock;
    boost::unique_lock<decltype(lock)> guard(lock);
    done.wait(guard, [&result] { return result!=0; });

This code is unsafe because result may not get set by the time the wait
predicate is checked, but may have become set and the notify issued before
the wait begins. This is an example of a lost wakeup.

An improved example might look like this:

    boost::condition_variable done;
    boost::mutex lock;
    int result=0;
    boost::thread([&]{
        {
            boost::lock_guard<decltype(lock)> guard(lock);
            result=78;
        }
        done.notify_one();
    });
    boost::unique_lock<decltype(lock)> guard(lock);
    done.wait(guard, [&result] { return result!=0; });

The above code may look safe: the predicate check for result being non-zero should
correctly detect if the thread executes and notifies before the lock in the main
thread is taken right? Potentially not: this is because `done.wait(guard, pred)`
is implemented as:

    while(!pred())
        wait(guard);

And the compiler's optimiser is permitted by the standard to believe that `result`
has not changed between its initialisation and the first test of its value, so in
fact the optimiser could compile this instead by eliding the first test of result
under the assumption that the predicate will always be false for its first execution:

    do {
        wait(guard);
    } while(!pred());

Now the race is obvious: if the closure could be executed by the spawned thread
and do the condition variable notify before the main thread gets to the point
of waiting, and the compiler's optimiser moves the test of the predicate to after the
condition variables sleep, the wakeup is ["lost]. I am not claiming any current
compiler actually does this, but I am claiming that one is depending on ["just happens]
behaviour, which is bad.

There are two solutions: first is to make `result` an atomic, thus forcing it always
to be checked. The second is to move the lock in the main thread to before the thread
creation, thus forcing the thread to only be executed once the wait has begun.


[heading:history The history of the permit object]

(The following section is written from his recollections by Niall Douglas)

The permit object originally started life in 2010 as a proposed nearest equivalent of C++
promise/futures for inclusion into the C11 standard by members of ISO WG14, whose
design was then implemented by myself into a reference C11 implementation.
Ultimately, it is not the purpose of a standards committee to standardise
features not yet in common usage, so the permit object reference implementation
was reworked into a POSIX threads extension and was submitted to the
Austin Working Group who develop POSIX, where I think it safe to say that the
reaction was of complete indifference -- the POSIX thread permit object, and its reference
implementation library written in C11, therefore fell by the wayside.

In 2014 during some consulting work on a C++ codebase which contained many unsafe uses
of `condition_variable`, the idea was had to wrap up the C11 reference
permit implementation as `boost::permit` and substitute all condition variables
with permits, thus avoiding a great deal of tedious manual repair work. The
client agreed to the proposal, and thus the Boost permit object herein came into
being.

You should note that the original C POSIX threads permit implementation remains
a fully functional, standalone implementation and its source code is included inside
Boost.Thread. It has some very useful features: a very low latency, spin-only wait
mode which works in shared memory; it doesn't use malloc, not once, which makes it
very useful for bootstrap or low latency usage; it can compose waits on multiple permits
at once; it can synchronise a kernel waitable object such as a file descriptor
or windows `HANDLE` with a permit's granted/ungranted state; and you can variously
hook the implementation with state change callbacks. In short, it's a very useful
reference implementation, and only a fraction of its functionality is sadly exposed
in this Boost permit object.

The POSIX threads permit objects were the product of effort by some of the world's
leading experts in concurrency - I am highly indebted to those on the WG14 committee who gave
so freely of their time and thoughts. My thanks in particular are due to Hans Boehm without whose
detailed feedback this proposal would look completely different. I would also like to thank Anthony
Williams for his commentary and feedback, and Nick Stoughton for his advice to me regarding becoming the
ISO JTC1 SC22 convenor for the Republic of Ireland and on how best to submit a proposal for incorporation
into the POSIX standard. My thanks are also due to John Benito, WG14 convenor, for his seemingly never
tiring efforts on the behalf of C-ish programmers everywhere.

Finally, I would like to thank the present Boost.Threads maintainer Vicente J. Botet Escriba
for being open to the idea of a new thread synchronisation object. One is usually best
advised to treat any proposal of an ["improved] threading object with the deepest suspicion.

[section:permit Class `permit<>`]

    //#include <boost/thread/permit.hpp>

    namespace boost
    {
        template<bool consuming=true> class permit
        {
        public:
            permit(bool initial_state=false);
            ~permit();

            void grant() noexcept;
            void revoke() noexcept;

            void notify_one() noexcept;  // if consuming=true
            void notify_all() noexcept;  // if consuming=false

            void wait(boost::unique_lock<boost::mutex>& lock);

            template<typename predicate_type>
            void wait(boost::unique_lock<boost::mutex>& lock,predicate_type predicate);

            template <class Clock, class Duration>
            typename cv_status::type
            wait_until(
                unique_lock<mutex>& lock,
                const chrono::time_point<Clock, Duration>& t);

            template <class Clock, class Duration, class Predicate>
            bool
            wait_until(
                unique_lock<mutex>& lock,
                const chrono::time_point<Clock, Duration>& t,
                Predicate pred);

            template <class Rep, class Period>
            typename cv_status::type
            wait_for(
                unique_lock<mutex>& lock,
                const chrono::duration<Rep, Period>& d);

            template <class Rep, class Period, class Predicate>
            bool
            wait_for(
                unique_lock<mutex>& lock,
                const chrono::duration<Rep, Period>& d,
                Predicate pred);

        #if defined BOOST_THREAD_USES_DATETIME
            bool timed_wait(boost::unique_lock<boost::mutex>& lock,boost::system_time const& abs_time);
            template<typename duration_type>
            bool timed_wait(boost::unique_lock<boost::mutex>& lock,duration_type const& rel_time);
            template<typename predicate_type>
            bool timed_wait(boost::unique_lock<boost::mutex>& lock,boost::system_time const& abs_time,predicate_type predicate);
            template<typename duration_type,typename predicate_type>
            bool timed_wait(boost::unique_lock<boost::mutex>& lock,duration_type const& rel_time,predicate_type predicate);
            bool timed_wait(boost::unique_lock<boost::mutex>& lock,boost::xtime const& abs_time);

            template<typename predicate_type>
            bool timed_wait(boost::unique_lock<boost::mutex>& lock,boost::xtime const& abs_time,predicate_type predicate);
        #endif

        };
    }

[section:constructor `permit(bool initial_state=false)`]

[variablelist

[[Effects:] [Constructs an object of class `permit` with initial state set to `initial_state`.]]

[[Throws:] [__thread_resource_error__ if an error occurs.]]

]

[endsect]

[section:destructor `~permit()`]

[variablelist

[[Effects:] [Destroys the object. It is safe to destroy the object while other threads are
also waiting upon or granting upon or revoking upon the same object. In that situation,
waits will complete immediately (potentially with exception) and grants and revokes will
exit (potentially with exception).]]

[[Throws:] [Nothing.]]

]

[endsect]

[section:grant `void grant()`]

[variablelist

[[Effects:] [Grants permit to one waiting thread, blocking until that one waiting thread is
released. If there is no waiting thread, gives permit to the next thread to wait and returns
immediately.

If the permit is consuming, the permit is atomically transferred to the winning thread.

If the permit is non-consuming, the permit is still atomically transferred to
the winning thread, but the permit is atomically regranted. You are furthermore guaranteed that exactly
every waiter at the time of grant will be released before the grant operation returns. Note that
because of this guarantee, only one grant may occur at any one time per permit instance i.e. grant is a
critical section. This implies that if a grant is operating, any new waits hold until the grant
completes.
]]

[[Throws:] [Nothing.]]

]

[endsect]

[section:revoke `void revoke()`]

[variablelist

[[Effects:] [Revoke any outstanding permit, causing any subsequent waiters to wait.]]

[[Throws:] [Nothing.]]

]

[endsect]

[section:notify_one `void notify_one()`]

[variablelist

[[Precondition:] [Only available if consuming is true, otherwise static asserts.]]

[[Effects:] [Same as `grant()`.]]

[[Throws:] [Nothing.]]

]

[endsect]

[section:notify_all `void notify_all()`]

[variablelist

[[Precondition:] [Only available if consuming is false, otherwise static asserts.]]

[[Effects:] [Same as `grant()` followed by a `revoke()`.]]

[[Throws:] [Nothing.]]

]

[endsect]

[section:wait `void wait(boost::unique_lock<boost::mutex>& lock)`]

[variablelist

[[Precondition:] [`lock` is locked by the current thread, and either no other
thread is currently waiting on `*this`, or the execution of the `mutex()` member
function on the `lock` objects supplied in the calls to `wait` or `timed_wait`
in all the threads currently waiting on `*this` would return the same value as
`lock->mutex()` for this call to `wait`.]]

[[Effects:] [If the permit is available, atomically consumes the permit and if the
permit is non-consuming, atomically regrants the permit for future waiters. If the
permit is not available, atomically calls `lock.unlock()` and blocks the current thread. The
thread will unblock when and only when a permit is atomically gained by the waiting thread,
whereupon the lock is reacquired by invoking `lock.lock()` before the call to
`wait` returns. The lock is also reacquired by invoking `lock.lock()` if the
function exits with an exception.

If the permit is non-consuming, note that grants are serialised with one another and no new waits may begin
while a grant is occurring. This guarantees that non-consuming grants always release all waiters
waiting at the point of grant.
]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[endsect]

[section:wait_predicate `template<typename predicate_type> void wait(boost::unique_lock<boost::mutex>& lock, predicate_type pred)`]

[variablelist

[[Effects:] [As-if ``
while(!pred())
{
    wait(lock);
}
``]]

]

[endsect]

[section:timed_wait `bool timed_wait(boost::unique_lock<boost::mutex>& lock,boost::system_time const& abs_time)`]

[variablelist

[[Precondition:] [`lock` is locked by the current thread, and either no other
thread is currently waiting on `*this`, or the execution of the `mutex()` member
function on the `lock` objects supplied in the calls to `wait` or `timed_wait`
in all the threads currently waiting on `*this` would return the same value as
`lock->mutex()` for this call to `wait`.]]

[[Effects:] [If the permit is available, atomically consumes the permit and if the
permit is non-consuming, atomically regrants the permit for future waiters. If the
permit is not available, atomically calls `lock.unlock()` and blocks the current thread. The
thread will unblock when and only when a permit is atomically gained by the waiting thread
or when the time as reported by `boost::get_system_time()` would be equal to or later than
the specified `abs_time`, whereupon the lock is reacquired by invoking `lock.lock()` before the call to
`wait` returns. The lock is also reacquired by invoking `lock.lock()` if the
function exits with an exception.

If the permit is non-consuming, note that grants are serialised with one another and no new waits may begin
while a grant is occurring. This guarantees that non-consuming grants always release all waiters
waiting at the point of grant, but it may also mean that a poll-only timed wait may block
for a short while.
]]

[[Returns:] [`false` if the call is returning because the time specified by
`abs_time` was reached, `true` otherwise.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[endsect]

[section:timed_wait_rel `template<typename duration_type> bool timed_wait(boost::unique_lock<boost::mutex>& lock,duration_type const& rel_time)`]

[variablelist

[[Precondition:] [`lock` is locked by the current thread, and either no other
thread is currently waiting on `*this`, or the execution of the `mutex()` member
function on the `lock` objects supplied in the calls to `wait` or `timed_wait`
in all the threads currently waiting on `*this` would return the same value as
`lock->mutex()` for this call to `wait`.]]

[[Effects:] [If the permit is available, atomically consumes the permit and if the
permit is non-consuming, atomically regrants the permit for future waiters. If the
permit is not available, atomically calls `lock.unlock()` and blocks the current thread. The
thread will unblock when and only when a permit is atomically gained by the waiting thread
or after the period of time indicated by the `rel_time`
argument has elapsed, whereupon the lock is reacquired by invoking `lock.lock()` before the call to
`wait` returns. The lock is also reacquired by invoking `lock.lock()` if the
function exits with an exception.

If the permit is non-consuming, note that grants are serialised with one another and no new waits may begin
while a grant is occurring. This guarantees that non-consuming grants always release all waiters
waiting at the point of grant, but it may also mean that a poll-only timed wait may block
for a short while.
]]

[[Returns:] [`false` if the call is returning because the time period specified
by `rel_time` has elapsed, `true` otherwise.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[note The duration overload of timed_wait is difficult to use correctly. The overload taking a predicate should be preferred in most cases.]

[endsect]

[section:timed_wait_predicate `template<typename predicate_type> bool timed_wait(boost::unique_lock<boost::mutex>& lock, boost::system_time const& abs_time, predicate_type pred)`]

[variablelist

[[Effects:] [As-if ``
while(!pred())
{
    if(!timed_wait(lock,abs_time))
    {
        return pred();
    }
}
return true;
``]]

]

[endsect]


[section:wait_until `template <class Clock, class Duration> cv_status wait_until(boost::unique_lock<boost::mutex>& lock, const chrono::time_point<Clock, Duration>& abs_time)`]

[variablelist

[[Precondition:] [`lock` is locked by the current thread, and either no other
thread is currently waiting on `*this`, or the execution of the `mutex()` member
function on the `lock` objects supplied in the calls to `wait` or `wait_for` or `wait_until`
in all the threads currently waiting on `*this` would return the same value as
`lock->mutex()` for this call to `wait`.]]

[[Effects:] [If the permit is available, atomically consumes the permit and if the
permit is non-consuming, atomically regrants the permit for future waiters. If the
permit is not available, atomically calls `lock.unlock()` and blocks the current thread. The
thread will unblock when and only when a permit is atomically gained by the waiting thread
or when the time as reported by `Clock::now()`would be equal to or later than the specified `abs_time`, whereupon the lock is reacquired by invoking `lock.lock()` before the call to
`wait` returns. The lock is also reacquired by invoking `lock.lock()` if the
function exits with an exception.

If the permit is non-consuming, note that grants are serialised with one another and no new waits may begin
while a grant is occurring. This guarantees that non-consuming grants always release all waiters
waiting at the point of grant, but it may also mean that a poll-only timed wait may block
for a short while.
]]

[[Returns:] [`cv_status::timeout` if the call is returning because the time specified by
`abs_time` was reached, `cv_status::no_timeout` otherwise.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[endsect]

[section:wait_for `template <class Rep, class Period> cv_status wait_for(boost::unique_lock<boost::mutex>& lock, const chrono::duration<Rep, Period>& rel_time)`]


[variablelist

[[Precondition:] [`lock` is locked by the current thread, and either no other
thread is currently waiting on `*this`, or the execution of the `mutex()` member
function on the `lock` objects supplied in the calls to `wait` or `wait_until` or `wait_for`
in all the threads currently waiting on `*this` would return the same value as
`lock->mutex()` for this call to `wait`.]]

[[Effects:] [If the permit is available, atomically consumes the permit and if the
permit is non-consuming, atomically regrants the permit for future waiters. If the
permit is not available, atomically calls `lock.unlock()` and blocks the current thread. The
thread will unblock when and only when a permit is atomically gained by the waiting thread
or after the period of time indicated by the `rel_time`
argument has elapsed, whereupon the lock is reacquired by invoking `lock.lock()` before the call to
`wait` returns. The lock is also reacquired by invoking `lock.lock()` if the
function exits with an exception.

If the permit is non-consuming, note that grants are serialised with one another and no new waits may begin
while a grant is occurring. This guarantees that non-consuming grants always release all waiters
waiting at the point of grant, but it may also mean that a poll-only timed wait may block
for a short while.
]]

[[Returns:] [`cv_status::timeout ` if the call is returning because the time period specified
by `rel_time` has elapsed, `cv_status::no_timeout ` otherwise.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[note The duration overload of timed_wait is difficult to use correctly. The overload taking a predicate should be preferred in most cases.]

[endsect]

[section:wait_until_predicate `template <class Clock, class Duration, class Predicate> bool wait_until(boost::unique_lock<boost::mutex>& lock, const chrono::time_point<Clock, Duration>& abs_time, Predicate pred)`]


[variablelist

[[Effects:] [As-if ``
while(!pred())
{
    if(!wait_until(lock,abs_time))
    {
        return pred();
    }
}
return true;
``]]

]

[endsect]

[section:wait_for_predicate `template <class Rep, class Period, class Predicate> bool wait_for(boost::unique_lock<boost::mutex>& lock, const chrono::duration<Rep, Period>& rel_time, Predicate pred)`]


[variablelist

[[Effects:] [As-if ``
return wait_until(lock, chrono::steady_clock::now() + d, boost::move(pred));
``]]

]

[endsect]




[endsect]

[section:permit_any Class `permit_any`]

    //#include <boost/thread/permit.hpp>

    namespace boost
    {
        template<bool consuming=true> class permit_any
        {
        public:
            permit_any(bool initial_state=false);
            ~permit_any();

            void grant() noexcept;
            void revoke() noexcept;

            void notify_one() noexcept;  // if consuming=true
            void notify_all() noexcept;  // if consuming=false

            template<typename lock_type>
            void wait(lock_type& lock);

            template<typename lock_type,typename predicate_type>
            void wait(lock_type& lock,predicate_type predicate);

            template <class lock_type, class Clock, class Duration>
            cv_status wait_until(
                lock_type& lock,
                const chrono::time_point<Clock, Duration>& t);

            template <class lock_type, class Clock, class Duration, class Predicate>
            bool wait_until(
                lock_type& lock,
                const chrono::time_point<Clock, Duration>& t,
                Predicate pred);


            template <class lock_type, class Rep, class Period>
            cv_status wait_for(
                lock_type& lock,
                const chrono::duration<Rep, Period>& d);

            template <class lock_type, class Rep, class Period, class Predicate>
            bool wait_for(
                lock_type& lock,
                const chrono::duration<Rep, Period>& d,
                Predicate pred);

        #if defined BOOST_THREAD_USES_DATETIME
            template<typename lock_type>
            bool timed_wait(lock_type& lock,boost::system_time const& abs_time);
            template<typename lock_type,typename duration_type>
            bool timed_wait(lock_type& lock,duration_type const& rel_time);
            template<typename lock_type,typename predicate_type>
            bool timed_wait(lock_type& lock,boost::system_time const& abs_time,predicate_type predicate);
            template<typename lock_type,typename duration_type,typename predicate_type>
            bool timed_wait(lock_type& lock,duration_type const& rel_time,predicate_type predicate);
            template<typename lock_type>
            bool timed_wait(lock_type>& lock,boost::xtime const& abs_time);
            template<typename lock_type,typename predicate_type>
            bool timed_wait(lock_type& lock,boost::xtime const& abs_time,predicate_type predicate);
        #endif
        };
    }

[section:constructor `permit_any(bool initial_state=false)`]

[variablelist

[[Effects:] [Constructs an object of class `permit_any` with initial state set to `initial_state`.]]

[[Throws:] [__thread_resource_error__ if an error occurs.]]

]

[endsect]

[section:destructor `~permit_any()`]

[variablelist

[[Effects:] [Destroys the object. It is safe to destroy the object while other threads are
also waiting upon or granting upon or revoking upon the same object. In that situation,
waits will complete immediately (potentially with exception) and grants and revokes will
exit (potentially with exception).]]

[[Throws:] [Nothing.]]

]

[endsect]

[section:grant `void grant()`]

[variablelist

[[Effects:] [Grants permit to one waiting thread, blocking until that one waiting thread is
released. If there is no waiting thread, gives permit to the next thread to wait and returns
immediately.

If the permit is consuming, the permit is atomically transferred to the winning thread.

If the permit is non-consuming, the permit is still atomically transferred to
the winning thread, but the permit is atomically regranted. You are furthermore guaranteed that exactly
every waiter at the time of grant will be released before the grant operation returns. Note that
because of this guarantee, only one grant may occur at any one time per permit instance i.e. grant is a
critical section. This implies that if a grant is operating, any new waits hold until the grant
completes.
]]

[[Throws:] [Nothing.]]

]

[endsect]

[section:revoke `void revoke()`]

[variablelist

[[Effects:] [Revoke any outstanding permit, causing any subsequent waiters to wait.]]

[[Throws:] [Nothing.]]

]

[endsect]

[section:notify_one `void notify_one()`]

[variablelist

[[Precondition:] [Only available if consuming is true, otherwise static asserts.]]

[[Effects:] [Same as `grant()`.]]

[[Throws:] [Nothing.]]

]

[endsect]

[section:notify_all `void notify_all()`]

[variablelist

[[Precondition:] [Only available if consuming is false, otherwise static asserts.]]

[[Effects:] [Same as `grant()` followed by a `revoke()`.]]

[[Throws:] [Nothing.]]

]

[endsect]

[section:wait `template<typename lock_type> void wait(lock_type& lock)`]

[variablelist

[[Effects:] [If the permit is available, atomically consumes the permit and if the
permit is non-consuming, atomically regrants the permit for future waiters. If the
permit is not available, atomically calls `lock.unlock()` and blocks the current thread. The
thread will unblock when and only when a permit is atomically gained by the waiting thread,
whereupon the lock is reacquired by invoking `lock.lock()` before the call to
`wait` returns. The lock is also reacquired by invoking `lock.lock()` if the
function exits with an exception.

If the permit is non-consuming, note that grants are serialised with one another and no new waits may begin
while a grant is occurring. This guarantees that non-consuming grants always release all waiters
waiting at the point of grant.
]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[endsect]

[section:wait_predicate `template<typename lock_type,typename predicate_type> void wait(lock_type& lock, predicate_type pred)`]

[variablelist

[[Effects:] [As-if ``
while(!pred())
{
    wait(lock);
}
``]]

]

[endsect]

[section:timed_wait `template<typename lock_type> bool timed_wait(lock_type& lock,boost::system_time const& abs_time)`]

[variablelist

[[Effects:] [If the permit is available, atomically consumes the permit and if the
permit is non-consuming, atomically regrants the permit for future waiters. If the
permit is not available, atomically calls `lock.unlock()` and blocks the current thread. The
thread will unblock when and only when a permit is atomically gained by the waiting thread
or when the time as reported by `boost::get_system_time()` would be equal to or later than
the specified `abs_time`, whereupon the lock is reacquired by invoking `lock.lock()` before the call to
`wait` returns. The lock is also reacquired by invoking `lock.lock()` if the
function exits with an exception.

If the permit is non-consuming, note that grants are serialised with one another and no new waits may begin
while a grant is occurring. This guarantees that non-consuming grants always release all waiters
waiting at the point of grant, but it may also mean that a poll-only timed wait may block
for a short while.
]]

[[Returns:] [`false` if the call is returning because the time specified by
`abs_time` was reached, `true` otherwise.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[endsect]

[section:timed_wait_rel `template<typename lock_type,typename duration_type> bool timed_wait(lock_type& lock,duration_type const& rel_time)`]

[variablelist

[[Effects:] [If the permit is available, atomically consumes the permit and if the
permit is non-consuming, atomically regrants the permit for future waiters. If the
permit is not available, atomically calls `lock.unlock()` and blocks the current thread. The
thread will unblock when and only when a permit is atomically gained by the waiting thread
or after the period of time indicated by the `rel_time`
argument has elapsed, whereupon the lock is reacquired by invoking `lock.lock()` before the call to
`wait` returns. The lock is also reacquired by invoking `lock.lock()` if the
function exits with an exception.

If the permit is non-consuming, note that grants are serialised with one another and no new waits may begin
while a grant is occurring. This guarantees that non-consuming grants always release all waiters
waiting at the point of grant, but it may also mean that a poll-only timed wait may block
for a short while.
]]

[[Returns:] [`false` if the call is returning because the time period specified
by `rel_time` has elapsed, `true` otherwise.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[note The duration overload of timed_wait is difficult to use correctly. The overload taking a predicate should be preferred in most cases.]

[endsect]

[section:timed_wait_predicate `template<typename lock_type,typename predicate_type> bool timed_wait(lock_type& lock, boost::system_time const& abs_time, predicate_type pred)`]

[variablelist

[[Effects:] [As-if ``
while(!pred())
{
    if(!timed_wait(lock,abs_time))
    {
        return pred();
    }
}
return true;
``]]

]

[endsect]

[section:wait_until `template <class lock_type, class Clock, class Duration> cv_status wait_until(lock_type& lock, const chrono::time_point<Clock, Duration>& abs_time)`]

[variablelist

[[Effects:] [If the permit is available, atomically consumes the permit and if the
permit is non-consuming, atomically regrants the permit for future waiters. If the
permit is not available, atomically calls `lock.unlock()` and blocks the current thread. The
thread will unblock when and only when a permit is atomically gained by the waiting thread
or when the time as reported by `Clock::now()`would be equal to or later than the specified `abs_time`, whereupon the lock is reacquired by invoking `lock.lock()` before the call to
`wait` returns. The lock is also reacquired by invoking `lock.lock()` if the
function exits with an exception.

If the permit is non-consuming, note that grants are serialised with one another and no new waits may begin
while a grant is occurring. This guarantees that non-consuming grants always release all waiters
waiting at the point of grant, but it may also mean that a poll-only timed wait may block
for a short while.
]]

[[Returns:] [`cv_status::timeout` if the call is returning because the time specified by
`abs_time` was reached, `cv_status::no_timeout` otherwise.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[endsect]

[section:wait_for `template <class lock_type, class Rep, class Period> cv_status wait_for(lock_type& lock, const chrono::duration<Rep, Period>& rel_time)`]

[variablelist

[[Effects:] [If the permit is available, atomically consumes the permit and if the
permit is non-consuming, atomically regrants the permit for future waiters. If the
permit is not available, atomically calls `lock.unlock()` and blocks the current thread. The
thread will unblock when and only when a permit is atomically gained by the waiting thread
or after the period of time indicated by the `rel_time`
argument has elapsed, whereupon the lock is reacquired by invoking `lock.lock()` before the call to
`wait` returns. The lock is also reacquired by invoking `lock.lock()` if the
function exits with an exception.

If the permit is non-consuming, note that grants are serialised with one another and no new waits may begin
while a grant is occurring. This guarantees that non-consuming grants always release all waiters
waiting at the point of grant, but it may also mean that a poll-only timed wait may block
for a short while.
]]

[[Returns:] [`cv_status::timeout` if the call is returning because the time specified by
`abs_time` was reached, `cv_status::no_timeout` otherwise.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[note The duration overload of timed_wait is difficult to use correctly. The overload taking a predicate should be preferred in most cases.]

[endsect]

[section:wait_until_predicate `template <class lock_type, class Clock, class Duration, class Predicate> bool wait_until(lock_type& lock, const chrono::time_point<Clock, Duration>& abs_time, Predicate pred)`]

[variablelist

[[Effects:] [As-if ``
while(!pred())
{
    if(!__cvany_wait_until(lock,abs_time))
    {
        return pred();
    }
}
return true;
``]]

]

[endsect]

[endsect]

[endsect]
