<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="keywords" content="threads, BTL, thread library, C++">
<link rel="stylesheet" type="text/css" href="styles.css">
<title>Boost.Threads, scoped_timed_lock</title>
</head>

<body bgcolor="#FFFFFF" link="#0000FF" vlink="#800080">

<table border="0" cellpadding="7" cellspacing="0" width="100%">
    <tr>
        <td valign="top" width="300">
			<h3><img src="../../../c++boost.gif" alt="C++ Boost" width="277" height="86"></h3>
        </td>
        <td valign="top">
			<h1 align="center">Boost.Threads</h1>
			<h2 align="center">scoped_timed_lock</h2>
        </td>
    </tr>
</table>

<hr>

<p><a href="#Introduction">Introduction</a><br>
<a href="#Header">Header</a><br>
<a href="#Synopsis">Synopsis</a><br>
<a href="#Members">Members</a><br>
<a href="#Example">Example</a></p>

<h2><a name="Introduction">Introduction</a></h2>

<p>This class template defines a generic lock type which meets the
<a href="lock_concept.html#ScopedTimedLock">ScopedTimedLock</a> requirements. The
<a href="mutex.html">timed_mutex</a> and
<a href="recursive_mutex.html">recursive_timed_mutex</a> classes use this template to
define their <code>scoped_timed_lock</code> types.</p>

<p>Like all the <b>Boost.Threads</b> <a href="lock_concept.html">lock models</a>,
<code>scoped_timed_lock</code> objects are meant to be short-lived. Objects of the
class are not <a href="definitions.html#thread-safe">thread-safe</a>, and so should
not be shared between threads.</p>

<p>Class <code>scoped_timed_lock</code> follows the &quot;resource acquisition is
initialization&quot; idiom <a href="bibliography.html#Stroustrup-00">[Stroustrup
00 14.4.1]</a> and is a realization of the &quot;Scoped Locking Pattern&quot;
<a href="bibliography.html#Schmidt-00">[Schmidt-00]</a>. Thus the usage is to let the
constructor do the locking, and then let the destructor do the unlocking automatically
at the end of the enclosing scope. The lock() and unlock() members are usually not
explicitly called, but are provided to allow for complex overlapping locks of multiple
mutexes.</p>

<p>The type used to instantiate the class must meet the
<a href="mutex_concept.html#TimedMutex">TimedMutex</a> requirements.</p>

<p>Although this class is an implementation detail, it is publicly documented here because
of its importance.</p>

<h2><a name="Header">Header</a></h2>

<pre>
#include <a href="../../../boost/thread/detail/lock.hpp">&lt;boost/thread/detail/lock.hpp&gt;</a>
    <i>This header is usually not included directly by programmers
    because it is supplied by <a href="../../../boost/thread/mutex.hpp">&lt;boost/thread/mutex.hpp&gt;</a> or
    <a href="../../../boost/thread/recursive_mutex.hpp">&lt;boost/thread/recursive_mutex.hpp&gt;</a></i>
</pre>

<h2><a name="Synopsis">Synopsis</a></h2>

<pre>
namespace boost { namespace detail { namespace thread {
    template &lt;typename TimedMutex&gt;
    class scoped_timed_lock : private <a href="../../utility/utility.htm#Class noncopyable">boost::noncopyable</a> // Exposition only.
        // Class scoped_timed_lock meets the <a href="overview.html#NonCopyable">NonCopyable</a> requirement.
    {
    public:
        typedef TimedMutex mutex_type;

        scoped_timed_lock(TimedMutex&amp; mx, const boost::xtime&amp; xt);
        scoped_timed_lock(TimedMutex&amp; mx, bool initially_locked);
        ~scoped_timed_lock();
        
        void lock();
        bool timed_lock(const xtime&amp; xt);
        void unlock();
        
        operator const void*() const;
    };
} // namespace thread
} // namesapce detail
} // namespace boost
</pre>

<h2><a name="Members">Members</a></h2>

<hr>

<h3>Constructor</h3>

<pre>
    scoped_timed_lock(TimedMutex&amp; mx, const <a href="xtime.html">xtime</a>&amp; xt);
</pre>

<p><b>Effects:</b> Associates mutex <code>mx</code> with <code>*this</code>.
Calls <code>timed_lock</code>( <code>xt</code>)</p>

<hr>

<pre>
    scoped_timed_lock(TimedMutex&amp; mx, bool initially_locked);
</pre>

<p><b>Effects:</b> Associates mutex <code>mx</code> with <code>*this</code>.
If <code>initially_locked</code> is <code>true</code>, calls <code>lock()</code>.</p>

<hr>

<h3>Destructor</h3>

<pre>
    ~scoped_timed_lock();
</pre>

<p><b>Effects:</b> If <code> locked()</code>, calls <code>unlock()</code>. Destroys
<code>*this</code>.</p>

<hr>

<h3>lock</h3>

<pre>
    void lock();
</pre>

<p><b>Effects:</b>  If the associated mutex is already locked by another lock in the
current thread, the effects depend on the locking strategy of the associated mutex, as
shown in the following table:</p>

<table border="1" cellpadding="5">
  <tr>
    <td><i><a href="mutex_concept.html#LockingStrategies">Locking Strategy</a><br>
      of associated mutex</i></td>
    <td><i>Effect if associated mutex is already locked by the current thread</i></td>
  </tr>
  <tr>
    <td>Recursive</td>
    <td>As if an additional lock were added to the mutex.</td>
  </tr>
  <tr>
    <td>Checked</td>
    <td>Throws <a href="lock_error.html">lock_error</a>.</td>
  </tr>
  <tr>
    <td>Unchecked</td>
    <td>Undefined behavior [<a href="bibliography.html#ISO">ISO</a> 1.3.12] (but
      typically, <a href="definitions.html#Deadlock">deadlock</a>.)</td>
  </tr>
</table>

<p>If the associated mutex is already locked by some other thread, places the
current thread in the <a href="definitions.html#State">Blocked</a> state until
the associated mutex is unlocked, after which the current thread is placed in
the <a href="definitions.html#State">Ready</a> state, eventually to be returned
to the <a href="definitions.html#State">Running</a> state. Places the associated
mutex in the locked state.

<p><b>Throws:</b> <a href="lock_error.html">lock_error</a> if <code>locked()</code> or
as indicated in <b>Effects</b>.</p>

<hr>

<h3>timed_lock</h3>

<pre>
    bool timed_lock(const <a href="xtime.html">xtime</a>&amp; xt);
</pre>

<p><b>Effects:</b>  Same as <code>lock()</code>, except that if xt is reached,
places the current thread in the <a href="definitions.html#State">Ready</a> 
state without further ado.</p>

<p><b>Returns:</b> <code>locked()</code>.</p>

<p><b>Throws:</b> <a href="lock_error.html">lock_error</a> if <code>locked()</code> or
as indicated in <b>Effects</b>.</p>

<hr>

<h3>unlock</h3>

<pre>
    void unlock();
</pre>

<p><b>Effects: </b>Unlocks the associated mutex.</p>

<p><b>Throws:</b> <a href="lock_error.html">lock_error</a> if <code>!locked()</code>.</p>

<hr>

<h3>const void* Conversion</h3>

<pre>
    operator const void*() const;
</pre>

<p><b>Returns:</b> If the associated mutex is currently locked, a value convertible to
<code>true</code>, else a value convertible to <code>false</code>.</p>

<p><b>Rationale:</b> A <code>const void*</code> conversion is considered safer than a
conversion to <code>bool</code>.</p>

<hr>
<h3>locked</h3>

<pre>
    bool locked() const;
</pre>

<p><b>Returns:</b>  <code>this-&gt;operator const void*() != 0</code>.</p>

<hr>

<h2><a name="Example">Example</a> Usage</h2>

<pre>
#include &lt;boost/thread/mutex.hpp&gt;
#include &lt;iostream&gt;

int main(int, char*[])
{
   boost::timed_mutex mutex;
   boost::xtime xt;
   boost::get_xtime(&amp;xt, boost::TIME_UTC);
   xt.sec += 1;
   boost::mutex::scoped_timed_lock scope_timed_lock(mutex, xt);
   if (scope_timed_lock.locked())
      std::cout &lt;&lt; &quot;locked&quot; &lt;&lt; std::endl;
   else
      std::cout &lt;&lt; &quot;unlocked&quot; &lt;&lt; std::endl;
   return 0;
}
</pre>

<p>The output is:</p>

<pre>
locked
</pre>

<hr>

<p>Revised <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%B %d, %Y" startspan -->October 01, 2001<!--webbot bot="Timestamp" endspan i-checksum="30079" -->
</p>

<p><i>© Copyright <a href="mailto:williamkempf@hotmail.com">William E. Kempf</a>
2001 all rights reserved.</i></p>

</body>
</html>
