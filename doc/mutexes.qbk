[/
  (C) Copyright 2007-11 Anthony Williams
  (C) Copyright 2011-12 Vicente J. Botet Escriba
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[section:mutex_types Mutex Types]

[section:mutex Class `mutex`]

    #include <boost/thread/mutex.hpp>

    class mutex:
        boost::noncopyable
    {
    public:
        mutex();
        ~mutex();
        
        void lock();
        bool try_lock();
        void unlock();

        typedef platform-specific-type native_handle_type;
        native_handle_type native_handle();
        
        typedef unique_lock<mutex> scoped_lock;
        typedef unspecified-type scoped_try_lock;
    };

__mutex__ implements the __lockable_concept__ to provide an exclusive-ownership mutex. At most one thread can own the lock on a given
instance of __mutex__ at any time. Multiple concurrent calls to __lock_ref__, __try_lock_ref__ and __unlock_ref__ shall be permitted.

[section:nativehandle Member function `native_handle()`]

    typedef platform-specific-type native_handle_type;
    native_handle_type native_handle();

[variablelist

[[Effects:] [Returns an instance of `native_handle_type` that can be used with platform-specific APIs to manipulate the underlying
implementation. If no such instance exists, `native_handle()` and `native_handle_type` are not present.]]

[[Throws:] [Nothing.]]

]

[endsect]


[endsect]

[section:try_mutex Typedef `try_mutex`]

    #include <boost/thread/mutex.hpp>

    typedef mutex try_mutex;

__try_mutex__ is a `typedef` to __mutex__, provided for backwards compatibility with previous releases of boost.

[endsect]

[section:timed_mutex Class `timed_mutex`]

    #include <boost/thread/mutex.hpp>

    class timed_mutex:
        boost::noncopyable
    {
    public:
        timed_mutex();
        ~timed_mutex();

        void lock();
        void unlock();
        bool try_lock();

        template <class Rep, class Period>
        bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);
        template <class Clock, class Duration>
        bool try_lock_until(const chrono::time_point<Clock, Duration>& t);

        typedef platform-specific-type native_handle_type;
        native_handle_type native_handle();

        typedef unique_lock<timed_mutex> scoped_timed_lock;
        typedef unspecified-type scoped_try_lock;
        typedef scoped_timed_lock scoped_lock;

    #if defined BOOST_THREAD_PROVIDES_DATE_TIME || defined BOOST_THREAD_DONT_USE_CHRONO
        bool timed_lock(system_time const & abs_time);
        template<typename TimeDuration>
        bool timed_lock(TimeDuration const & relative_time);
    #endif

    };

__timed_mutex__ implements the __timed_lockable_concept__ to provide an exclusive-ownership mutex. At most one thread can own the
lock on a given instance of __timed_mutex__ at any time. Multiple concurrent calls to __lock_ref__, __try_lock_ref__,
__timed_lock_ref__, __timed_lock_duration_ref__ and __unlock_ref__ shall be permitted.

[section:nativehandle Member function `native_handle()`]

    typedef platform-specific-type native_handle_type;
    native_handle_type native_handle();

[variablelist

[[Effects:] [Returns an instance of `native_handle_type` that can be used with platform-specific APIs to manipulate the underlying
implementation. If no such instance exists, `native_handle()` and `native_handle_type` are not present.]]

[[Throws:] [Nothing.]]

]

[endsect]

[endsect]

[section:recursive_mutex Class `recursive_mutex`]

    #include <boost/thread/recursive_mutex.hpp>

    class recursive_mutex:
        boost::noncopyable
    {
    public:
        recursive_mutex();
        ~recursive_mutex();
        
        void lock();
        bool try_lock() noexcept;
        void unlock();

        typedef platform-specific-type native_handle_type;
        native_handle_type native_handle();
        
        typedef unique_lock<recursive_mutex> scoped_lock;
        typedef unspecified-type scoped_try_lock;
    };

__recursive_mutex__ implements the __lockable_concept__ to provide an exclusive-ownership recursive mutex. At most one thread can
own the lock on a given instance of __recursive_mutex__ at any time. Multiple concurrent calls to __lock_ref__, __try_lock_ref__ and
__unlock_ref__ shall be permitted. A thread that already has exclusive ownership of a given __recursive_mutex__ instance can call
__lock_ref__ or __try_lock_ref__ to acquire an additional level of ownership of the mutex. __unlock_ref__ must be called once for
each level of ownership acquired by a single thread before ownership can be acquired by another thread.

[section:nativehandle Member function `native_handle()`]

    typedef platform-specific-type native_handle_type;
    native_handle_type native_handle();

[variablelist

[[Effects:] [Returns an instance of `native_handle_type` that can be used with platform-specific APIs to manipulate the underlying
implementation. If no such instance exists, `native_handle()` and `native_handle_type` are not present.]]

[[Throws:] [Nothing.]]

]

[endsect]

[endsect]

[section:recursive_try_mutex Typedef `recursive_try_mutex`]

    #include <boost/thread/recursive_mutex.hpp>

    typedef recursive_mutex recursive_try_mutex;

__recursive_try_mutex__ is a `typedef` to __recursive_mutex__, provided for backwards compatibility with previous releases of boost.

[endsect]

[section:recursive_timed_mutex Class `recursive_timed_mutex`]

    #include <boost/thread/recursive_mutex.hpp>

    class recursive_timed_mutex:
        boost::noncopyable
    {
    public:
        recursive_timed_mutex();
        ~recursive_timed_mutex();
        
        void lock();
        bool try_lock() noexcept;
        void unlock();


        template <class Rep, class Period>
        bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);
        template <class Clock, class Duration>
        bool try_lock_until(const chrono::time_point<Clock, Duration>& t);

        typedef platform-specific-type native_handle_type;
        native_handle_type native_handle();
        
        typedef unique_lock<recursive_timed_mutex> scoped_lock;
        typedef unspecified-type scoped_try_lock;
        typedef scoped_lock scoped_timed_lock;

    #if defined BOOST_THREAD_PROVIDES_DATE_TIME || defined BOOST_THREAD_DONT_USE_CHRONO
        bool timed_lock(system_time const & abs_time); 
        template<typename TimeDuration>
        bool timed_lock(TimeDuration const & relative_time);
    #endif

    };

__recursive_timed_mutex__ implements the __timed_lockable_concept__ to provide an exclusive-ownership recursive mutex. At most one
thread can own the lock on a given instance of __recursive_timed_mutex__ at any time. Multiple concurrent calls to __lock_ref__,
__try_lock_ref__, __timed_lock_ref__, __timed_lock_duration_ref__ and __unlock_ref__ shall be permitted. A thread that already has
exclusive ownership of a given __recursive_timed_mutex__ instance can call __lock_ref__, __timed_lock_ref__,
__timed_lock_duration_ref__ or __try_lock_ref__ to acquire an additional level of ownership of the mutex. __unlock_ref__ must be
called once for each level of ownership acquired by a single thread before ownership can be acquired by another thread.

[section:nativehandle Member function `native_handle()`]

    typedef platform-specific-type native_handle_type;
    native_handle_type native_handle();

[variablelist

[[Effects:] [Returns an instance of `native_handle_type` that can be used with platform-specific APIs to manipulate the underlying
implementation. If no such instance exists, `native_handle()` and `native_handle_type` are not present.]]

[[Throws:] [Nothing.]]

]

[endsect]

[endsect]

[include shared_mutex_ref.qbk]

[endsect]

[section:synchronized_value_ref Synchronized Values]


  namespace boost 
  {

    template<typename T, typename Lockable = mutex>
    class synchronized_value;

    // Specialized swap algorithm
    template <typename T, typename L>
    void swap(synchronized_value<T,L> & lhs, synchronized_value<T,L> & rhs);
    template <typename T, typename L>
    void swap(synchronized_value<T,L> & lhs, T & rhs);
    template <typename T, typename L>
    void swap(T & lhs, synchronized_value<T,L> & rhs);

    // Hash support
    template<typename T, typename L>
    struct hash<synchronized_value<T,L> >;

    // Comparison
    template <typename T, typename L>
    bool operator==(synchronized_value<T,L> const&lhs, synchronized_value<T,L> const& rhs)
    template <typename T, typename L>
    bool operator!=(synchronized_value<T,L> const&lhs, synchronized_value<T,L> const& rhs)
    template <typename T, typename L>
    bool operator<(synchronized_value<T,L> const&lhs, synchronized_value<T,L> const& rhs)
    template <typename T, typename L>
    bool operator<=(synchronized_value<T,L> const&lhs, synchronized_value<T,L> const& rhs)
    template <typename T, typename L>
    bool operator>(synchronized_value<T,L> const&lhs, synchronized_value<T,L> const& rhs)
    template <typename T, typename L>
    bool operator>=(synchronized_value<T,L> const&lhs, synchronized_value<T,L> const& rhs)

    // Comparison with T
    template <typename T, typename L>
    bool operator==(T const& lhs, synchronized_value<T,L> const&rhs);
    template <typename T, typename L>
    bool operator!=(T const& lhs, synchronized_value<T,L> const&rhs);
    template <typename T, typename L>
    bool operator<(T const& lhs, synchronized_value<T,L> const&rhs);
    template <typename T, typename L>
    bool operator<=(T const& lhs, synchronized_value<T,L> const&rhs);
    template <typename T, typename L>
    bool operator>(T const& lhs, synchronized_value<T,L> const&rhs);
    template <typename T, typename L>
    bool operator>=(T const& lhs, synchronized_value<T,L> const&rhs);

    template <typename T, typename L>
    bool operator==(synchronized_value<T,L> const& lhs, T const& rhs);
    template <typename T, typename L>
    bool operator!=(synchronized_value<T,L> const& lhs, T const& rhs);
    template <typename T, typename L>
    bool operator<(synchronized_value<T,L> const& lhs, T const& rhs);
    template <typename T, typename L>
    bool operator<=(synchronized_value<T,L> const& lhs, T const& rhs);
    template <typename T, typename L>
    bool operator>(synchronized_value<T,L> const& lhs, T const& rhs);
    template <typename T, typename L>
    bool operator>=(synchronized_value<T,L> const& lhs, T const& rhs);

  #if ! defined(BOOST_THREAD_NO_SYNCHRONIZE)
    template <typename ...SV>
    std::tuple<typename synchronized_value_strict_lock_ptr<SV>::type ...> synchronize(SV& ...sv);
  #endif
  }

[section:synchronized_value Class `synchronized_value`]

  #include <boost/thread/synchronized_value.hpp>

  namespace boost 
  {

    template<typename T, typename Lockable = mutex>
    class synchronized_value
    {
    public:
      typedef T value_type;
      typedef Lockable mutex_type;

      synchronized_value() noexept(is_nothrow_default_constructible<T>::value);
      synchronized_value(T const& other) noexept(is_nothrow_copy_constructible<T>::value);
      synchronized_value(T&& other) noexept(is_nothrow_move_constructible<T>::value);
      synchronized_value(synchronized_value const& rhs);
      synchronized_value(synchronized_value&& other);

      // mutation
      synchronized_value& operator=(synchronized_value const& rhs);
      synchronized_value& operator=(value_type const& val);
      void swap(synchronized_value & rhs);
      void swap(value_type & rhs);

      //observers
      T get() const;
    #if ! defined(BOOST_NO_CXX11_EXPLICIT_CONVERSION_OPERATORS)
      explicit operator T() const;
    #endif

      strict_lock_ptr<T,Lockable> operator->();
      const_strict_lock_ptr<T,Lockable> operator->() const;
      strict_lock_ptr<T,Lockable> synchronize();
      const_strict_lock_ptr<T,Lockable> synchronize() const;

      deref_value operator*();;
      const_deref_value operator*() const;

    private:
      T value_; // for exposition only
      mutable mutex_type mtx_;  // for exposition only
    };
  }

[variablelist

[[Requires:] [`Lockable` is `Lockable`.]]

]


[section:constructor `synchronized_value()`]

      synchronized_value() noexept(is_nothrow_default_constructible<T>::value);

[variablelist

[[Requires:] [`T` is `DefaultConstructible`.]]
[[Effects:] [Default constructs the cloaked value_type]]

[[Throws:] [Any exception thrown by `value_type()`.]]

]

[endsect]


[section:constructor_vt `synchronized_value(T const&)`]

      synchronized_value(T const& other) noexept(is_nothrow_copy_constructible<T>::value);

[variablelist

[[Requires:] [`T` is `CopyConstructible`.]]
[[Effects:] [Copy constructs the cloaked value_type using the parameter `other`]]

[[Throws:] [Any exception thrown by `value_type(other)`.]]

]

[endsect]

[section:copy_cons `synchronized_value(synchronized_value const&)`]

      synchronized_value(synchronized_value const& rhs);

[variablelist

[[Requires:] [`T` is `DefaultConstructible` and `Assignable`.]]
[[Effects:] [Assigns the value on a scope protected by the mutex of the rhs. The mutex is not copied.]]

[[Throws:] [Any exception thrown by `value_type()` or `value_type& operator=(value_type&)` or `mtx_.lock()`.]]

]

[endsect]

[section:move_vt `synchronized_value(T&&)`]

      synchronized_value(T&& other) noexept(is_nothrow_move_constructible<T>::value);

[variablelist

[[Requires:] [`T` is `CopyMovable `.]]
[[Effects:] [Move constructs the cloaked value_type]]

[[Throws:] [Any exception thrown by `value_type(value_type&&)`.]]

]

[endsect]

[section:move `synchronized_value(synchronized_value&&)`]

      synchronized_value(synchronized_value&& other);

[variablelist

[[Requires:] [`T` is `CopyMovable `.]]
[[Effects:] [Move constructs the cloaked value_type]]

[[Throws:] [Any exception thrown by `value_type(value_type&&)` or `mtx_.lock()`.]]

]

[endsect]

[section:assign `operator=(synchronized_value const&)`]

      synchronized_value& operator=(synchronized_value const& rhs);

[variablelist

[[Requires:] [`T` is `Assignale`.]]
[[Effects:] [Copies the underlying value on a scope protected by the two mutexes. The mutex is not copied. The locks are acquired avoiding deadlock. For example, there is no problem if one thread assigns `a = b` and the other assigns `b = a`.]]
[[Return:] [`*this`]]

[[Throws:] [Any exception thrown by `value_type& operator(value_type const&)` or `mtx_.lock()`.]]

]

[endsect]
[section:assign_vt `operator=(T const&)`]

      synchronized_value& operator=(value_type const& val);

[variablelist

[[Requires:] [`T` is `Assignale`.]]
[[Effects:] [Copies the value on a scope protected by the mutex.]]
[[Return:] [`*this`]]

[[Throws:] [Any exception thrown by `value_type& operator(value_type const&)` or `mtx_.lock()`.]]

]

[endsect]

[section:get `get() const`]

      T get() const;

[variablelist

[[Requires:] [`T` is `CopyConstructible`.]]
[[Return:] [`A copy of the protected value obtained on a scope protected by the mutex.`]]

[[Throws:] [Any exception thrown by `value_type(value_type const&)` or `mtx_.lock()`.]]

]

[endsect]


[section:T `operator T() const`]

    #if ! defined(BOOST_NO_CXX11_EXPLICIT_CONVERSION_OPERATORS)
      explicit operator T() const;
    #endif

[variablelist

[[Requires:] [`T` is `CopyConstructible`.]]
[[Return:] [`A copy of the protected value obtained on a scope protected by the mutex.`]]

[[Throws:] [Any exception thrown by `value_type(value_type const&)` or `mtx_.lock()`.]]

]

[endsect]

[section:swap `swap(synchronized_value&)`]

      void swap(synchronized_value & rhs);

[variablelist

[[Requires:] [`T` is `Assignale`.]]
[[Effects:] [Swaps the data on a scope protected by both mutex. Both mutex are acquired to avoid dead-lock. The mutexes are not swapped.]]

[[Throws:] [Any exception thrown by `swap(value_, rhs.value)` or `mtx_.lock()` or `rhs_.mtx_.lock()`.]]

]

[endsect]

[section:swap_vt `swap(synchronized_value&)`]

      void swap(value_type & rhs);

[variablelist

[[Requires:] [`T` is `Swapable`.]]
[[Effects:] [Swaps the data on a scope protected by both mutex. Both mutex are acquired to avoid dead-lock. The mutexes are not swapped.]]

[[Throws:] [Any exception thrown by `swap(value_, rhs)` or `mtx_.lock()`.]]

]

[endsect]
[section:indir `operator->()`]

      strict_lock_ptr<T,Lockable> operator->();


Essentially calling a method `obj->foo(x, y, z)` calls the method `foo(x, y, z)` inside a critical section as long-lived as the call itself.

[variablelist

[[Return:] [`A strict_lock_ptr<>.`]]

[[Throws:] [Nothing.]]

]

[endsect]
[section:indir_const `operator->() const`]

      const_strict_lock_ptr<T,Lockable> operator->() const;


If the `synchronized_value` object involved is const-qualified, then you'll only be able to call const methods
through `operator->`. So, for example, `vec->push_back("xyz")` won't work if `vec` were const-qualified.
The locking mechanism capitalizes on the assumption that const methods don't modify their underlying data.

[variablelist

[[Return:] [`A const_strict_lock_ptr <>.`]]

[[Throws:] [Nothing.]]

]

[endsect]
[section:synchronize `synchronize()`]

    strict_lock_ptr<T,Lockable> synchronize();

The synchronize() factory make easier to lock on a scope. As discussed, `operator->` can only lock over the duration of a call, so it is insufficient for complex operations. With `synchronize()` you get to lock the object in a scoped and to directly access the object inside that scope.

[*Example:]

  void fun(synchronized_value<vector<int>> & vec) {
    auto vec2=vec.synchronize();
    vec2.push_back(42);
    assert(vec2.back() == 42);
  }

[variablelist

[[Return:] [`A strict_lock_ptr <>.`]]

[[Throws:] [Nothing.]]

]

[endsect]
[section:synchronize_const `synchronize() const`]

    const_strict_lock_ptr<T,Lockable> synchronize() const;

[variablelist

[[Return:] [`A const_strict_lock_ptr <>.`]]

[[Throws:] [Nothing.]]

]

[endsect]

[section:deref `operator*()`]

      deref_value operator*();;

[variablelist

[[Return:] [`A an instance of a class that locks the mutex on construction and unlocks it on destruction and provides implicit conversion to a reference to the protected value.`]]

[[Throws:] [Nothing.]]

]

[endsect]
[section:deref_const `operator*() const`]

      const_deref_value operator*() const;


[variablelist

[[Return:] [`A an instance of a class that locks the mutex on construction and unlocks it on destruction and provides implicit conversion to a constant reference to the protected value.`]]

[[Throws:] [Nothing.]]

]

[endsect]




[endsect]
[section:synchronize Non-Member Function `synchronize`]

  #include <boost/thread/synchronized_value.hpp>
  namespace boost 
  {
  #if ! defined(BOOST_THREAD_NO_SYNCHRONIZE)
    template <typename ...SV>
    std::tuple<typename synchronized_value_strict_lock_ptr<SV>::type ...> synchronize(SV& ...sv);
  #endif
  }

[endsect]
[endsect]
