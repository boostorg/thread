<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE library PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN"
  "http://www.boost.org/tools/boostbook/dtd/boostbook.dtd" [
  <!ENTITY % thread.entities SYSTEM "entities.xml">
  %thread.entities;
]>
<!-- Copyright (c) 2002-2003 William E. Kempf, Michael Glassford
     Subject to the Boost Software License, Version 1.0. 
     (See accompanying file LICENSE-1.0 or  http://www.boost.org/LICENSE-1.0)
-->
<section id="thread.release_notes" last-revision="$Date$">
	<title>Release Notes</title>
    <section id="thread.release_notes.boost_1_34_0">
        <title>Boost 1.34.0</title>

        <section id="thread.release_notes.boost_1_34_0.change_log.maintainance">
            <title>New team of maintainers</title>

            <para>
                Since the original author William E. Kempf no longer is available to
                maintain the &Boost.Thread; library, a new team has been formed
                in an attempt to continue the work on &Boost.Thread;.
                Fortunately William E. Kempf has given
                <ulink url="http://lists.boost.org/Archives/boost/2006/09/110143.php">
                    permission </ulink> 
                to use his work under the boost license.
            </para>
            <para>
                The team currently consists of
                <itemizedlist>
                    <listitem>
                        Anthony Williams, for the Win32 platform,
                    </listitem>
                    <listitem>
                        Roland Schwarz, for the linux platform, and various "housekeeping" tasks.
                    </listitem>
                </itemizedlist>
                Volunteers for other platforms are welcome!
            </para>
            <para>
                As the &Boost.Thread; was kind of orphaned over the last release, this release
                attempts to fix the known bugs. Upcoming releases will bring in new things.
            </para>
        </section>

        <section id="thread.release_notes.boost_1_34_0.change_log.read_write_mutex">
            <title>read_write_mutex still broken</title>

            <para>
                <note>
                    It has been decided not to release the Read/Write Mutex, since the current
                    implementation suffers from a serious bug. The documentation of the concepts
                    has been included though, giving the interested reader an opportunity to study the
                    original concepts. Please refer to the following links if you are interested
                    which problems led to the decision to held back this mutex type.The issue
                    has been discovered before 1.33 was released and the code has
                    been omitted from that release. A reworked mutex is expected to appear in 1.35.
                    Also see:  
                    <ulink url="http://lists.boost.org/Archives/boost/2005/08/92307.php">
                        read_write_mutex bug</ulink> 
                    and 
                    <ulink url="http://lists.boost.org/Archives/boost/2005/09/93180.php">
                        read_write_mutex fundamentally broken in 1.33</ulink>
                </note>
            </para>
        </section>

    </section>
    <section id="thread.release_notes.boost_1_32_0">
		<title>Boost 1.32.0</title>

		<section id="thread.release_notes.boost_1_32_0.change_log.documentation">
			<title>Documentation converted to BoostBook</title>

			<para>The documentation was converted to BoostBook format,
			and a number of errors and inconsistencies were
			fixed in the process.
			Since this was a fairly large task, there are likely to be 
			more errors and inconsistencies remaining. If you find any,
			please report them!</para>
		</section>

		<section id="thread.release_notes.boost_1_32_0.change_log.static_link">
			<title>Statically-link build option added</title>

			<para>The option to link &Boost.Thread; as a static
			library has been added (with some limitations on Win32 platforms).
			This feature was originally removed from an earlier version
			of Boost because <classname>boost::thread_specific_ptr</classname>
			required that &Boost.Thread; be dynamically linked in order
			for its cleanup functionality to work on Win32 platforms.
			Because this limitation never applied to non-Win32 platforms,
			because significant progress has been made in removing
			the limitation on Win32 platforms (many thanks to
			Aaron LaFramboise and Roland Scwarz!), and because the lack
			of static linking is one of the most common complaints of
			&Boost.Thread; users, this decision was reversed.</para>
			
			<para>On non-Win32 platforms: 
			To choose the dynamically linked version of &Boost.Thread; 
			using Boost's auto-linking feature, #define BOOST_THREAD_USE_DLL;
			to choose the statically linked version, 
			#define BOOST_THREAD_USE_LIB. 
			If neither symbols is #defined, the default will be chosen.
			Currently the default is the statically linked version.</para>
			
			<para>On Win32 platforms using VC++: 
			Use the same #defines as for non-Win32 platforms 
			(BOOST_THREAD_USE_DLL and BOOST_THREAD_USE_LIB).
			If neither is #defined, the default will be chosen. 
			Currently the default is the statically linked version
			if the VC++ run-time library is set to
			"Multi-threaded" or "Multi-threaded Debug", and
			the dynamically linked version
			if the VC++ run-time library is set to 
			"Multi-threaded DLL" or "Multi-threaded Debug DLL".</para>
			
			<para>On Win32 platforms using compilers other than VC++:
			Use the same #defines as for non-Win32 platforms 
			(BOOST_THREAD_USE_DLL and BOOST_THREAD_USE_LIB).
			If neither is #defined, the default will be chosen. 
			Currently the default is the dynamically linked version
			because it has not yet been possible to implement automatic
			tss cleanup in the statically linked version for compilers
			other than VC++, although it is hoped that this will be
			possible in a future version of &Boost.Thread;.
			
			Note for advanced users: &Boost.Thread; provides several "hook"
			functions to allow users to experiment with the statically
			linked version on Win32 with compilers other than VC++.
			These functions are on_process_enter(), on_process_exit(),
			on_thread_enter(), and on_thread_exit(), and are defined
			in tls_hooks.cpp. See the comments in that file for more
			information.</para>
		</section>
		
		<section id="thread.release_notes.boost_1_32_0.change_log.barrier">
			<title>Barrier functionality added</title>

			<para>A new class, <classname>boost::barrier</classname>, was added.</para>
		</section>
		
		<section id="thread.release_notes.boost_1_32_0.change_log.read_write_mutex">
			<title>Read/write mutex functionality added</title>

			<para>New classes, 
			<classname>boost::read_write_mutex</classname>,
			<classname>boost::try_read_write_mutex</classname>, and
			<classname>boost::timed_read_write_mutex</classname>
			were added.
			
			<note>Since the read/write mutex and related classes are new,
			both interface and implementation are liable to change
			in future releases of &Boost.Thread;.
			The lock concepts and lock promotion in particular are
			still under discussion and very likely to change.</note>
			</para>
		</section>
		
		<section id="thread.release_notes.boost_1_32_0.change_log.thread_specific_ptr">
			<title>Thread-specific pointer functionality changed</title>

			<para>The <classname>boost::thread_specific_ptr</classname> 
			constructor now takes an optional pointer to a cleanup function that
			is called to release the thread-specific data that is being pointed
			to by <classname>boost::thread_specific_ptr</classname> objects.</para>

			<para>Fixed: the number of available thread-specific storage "slots"
			is too small on some platforms.</para>

			<para>Fixed: <functionname>thread_specific_ptr::reset()</functionname>
			doesn't check error returned by <functionname>tss::set()</functionname>
			(the <functionname>tss::set()</functionname> function now throws
			if it fails instead of returning an error code).</para>

			<para>Fixed: calling 
			<functionname>boost::thread_specific_ptr::reset()</functionname> or 
			<functionname>boost::thread_specific_ptr::release()</functionname>
			causes double-delete: once when 
			<functionname>boost::thread_specific_ptr::reset()</functionname> or
			<functionname>boost::thread_specific_ptr::release()</functionname> 
			is called and once when 
			<functionname>boost::thread_specific_ptr::~thread_specific_ptr()</functionname>
			is called.</para>
		</section>

		<section id="thread.release_notes.boost_1_32_0.change_log.mutex">
			<title>Mutex implementation changed for Win32</title>

			<para>On Win32, <classname>boost::mutex</classname>, 
			<classname>boost::try_mutex</classname>, <classname>boost::recursive_mutex</classname>,
			and <classname>boost::recursive_try_mutex</classname> now use a Win32 critical section 
			whenever possible; otherwise they use a Win32 mutex. As before, 
			<classname>boost::timed_mutex</classname> and 
			<classname>boost::recursive_timed_mutex</classname> use a Win32 mutex.</para>
		</section>

		<section id="thread.release_notes.boost_1_32_0.change_log.wince">
			<title>Windows CE support improved</title>

			<para>Minor changes were made to make Boost.Thread work on Windows CE.</para>
		</section>
	</section>
</section>
