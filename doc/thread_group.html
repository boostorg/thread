<html>
    <head>
        <meta http-equiv="Content-Type" content=
        "text/html; charset=iso-8859-1">
        <meta name="keywords" content="threads, BTL, thread library, C++">
        <link rel="stylesheet" type="text/css" href="styles.css">

        <title>Boost.Threads, thread_group</title>
    </head>

    <body bgcolor="#FFFFFF" link="#0000FF" vlink="#800080">
        <table summary="header" border="0" cellpadding="7" cellspacing="0"
        width="100%">
            <tr>
                <td valign="top" width="300">
                    <h3><img src="../../../c++boost.gif" alt="C++ Boost" width=
                    "277" height="86"></h3>
                </td>

                <td valign="top">
                    <h1 align="center">Boost.Threads</h1>

                    <h2 align="center">thread_group</h2>
                </td>
            </tr>
        </table>
        <hr>

        <p><a href="#Introduction">Introduction</a><br>
         <a href="#Header">Header</a><br>
         <a href="#Synopsis">Synopsis</a><br>
         <a href="#Members">Members</a><br>
         <a href="#Example">Example</a></p>

        <h2><a name="Introduction">Introduction</a></h2>

        <p>The <tt>thread_group</tt> class provides a container for easy
        grouping of threads to simplify several common thread creation and
        management idioms.</p>

        <p>All <tt>thread_group</tt> member functions are <a href=
        "definitions.html#thread-safe">thread-safe</a>, except destruction.</p>

        <h2><a name="Header">Header</a></h2>
<pre>
#include <a href=
"../../../boost/thread/thread.hpp">&lt;boost/thread/thread.hpp&gt;</a>
</pre>

        <h2><a name="Synopsis">Synopsis</a></h2>
<pre>
namespace boost
{
    class thread_group : <a href=
"../../utility/utility.htm#noncopyable">boost::noncopyable</a>
    {
    public:
        thread_group();
        ~thread_group();

        thread* create_thread(const boost::function0&lt;void&gt;&amp; threadfunc);
        void add_thread(thread* thrd);
        void remove_thread(thread* thrd);
        void join_all();
    };
}
</pre>

        <h2><a name="Members">Members</a></h2>
        <hr>

        <h3>Constructor</h3>
<pre>
    thread_group();
</pre>

        <p><b>Effects:</b> Constructs an empty <tt>thread_group</tt>
        container.</p>
        <hr>

        <h3>Destructor</h3>
<pre>
    ~thread_group();
</pre>

        <p><b>Effects:</b> Destroys each contained thread object. Destroys
        <code>*this</code>.</p>

        <p><b>Notes:</b> Behavior is undefined if another thread references
        *this during the execution of the destructor.</p>
        <hr>

        <h3>create_thread</h3>
<pre>
    thread* create_thread(const boost::function0&lt;void&gt;&amp; threadfunc);
</pre>

        <p><b>Effects:</b> Creates a new <tt>thread</tt> object that executes
        <tt>threadfunc</tt> and adds it to the <tt>thread_group</tt> container
        object&#39;s list of managed <tt>thread</tt> objects.</p>

        <p><b>Returns:</b> Pointer to the newly created thread.</p>
        <hr>

        <h3>add_thread</h3>
<pre>
    void add_thread(thread* thrd);
</pre>

        <p><b>Effects:</b> Adds <tt>thrd</tt> to the <tt>thread_group</tt>
        object&#39;s list of managed <tt>thread</tt> objects. The <tt>thrd</tt>
        object must have been allocated via operator new and will be deleted
        when the group is destroyed.</p>
        <hr>

        <h3>remove_thread</h3>
<pre>
    void remove_thread(thread* thrd);
</pre>

        <p><b>Effects:</b> Removes <code>*this</code>&#39;s list of managed
        <tt>thread</tt> objects.</p>

        <p><b>Throws:</b> ? if <tt>thrd</tt> is not it <code>*this</code>&#39;s
        list of managed <tt>thread</tt> objects.</p>
        <hr>

        <h3>join_all</h3>
<pre>
    void join_all();
</pre>

        <p><b>Effects:</b> Calls <code>join()</code> on each of the managed
        <tt>thread</tt> objects.</p>
        <hr>

        <h2><a name="Example">Example</a> Usage</h2>
<pre>
#include &lt;boost/thread/thread.hpp&gt;
#include &lt;iostream&gt;

int count = 0;
boost::mutex mutex;

void increment_count()
{
   boost::mutex::lock lock(mutex);
   std::cout &lt;&lt; &quot;count = &quot; &lt;&lt; ++count &lt;&lt; std::endl;
}

int main(int argc, char* argv[])
{
   boost::thread_group threads;
   for (int i = 0; i &lt; 10; ++i)
      threads.create_thread(&amp;increment_count);
   threads.join_all();
}
</pre>

        <p>The output is:</p>
<pre>
count = 1
count = 2
count = 3
count = 4
count = 5
count = 6
count = 7
count = 8
count = 9
count = 10
</pre>
        <hr>

        <p>Revised 
        <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B, %Y" startspan -->05 November, 2001<!--webbot bot="Timestamp" endspan i-checksum="39359" --></p>

        <p><i>&copy; Copyright <a href="mailto:williamkempf@hotmail.com">
        William E. Kempf</a> 2001 all rights reserved.</i></p>
    </body>
</html>

