<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="keywords" content="threads, BTL, thread library, C++">
<title>Boost.Threads, atomic_t</title>
</head>

<body bgcolor="#FFFFFF" link="#0000FF" vlink="#800080">

<table border="0" cellpadding="7" cellspacing="0" width="100%">
    <tr>
        <td valign="top" width="300">
			<h3><img src="../../../c++boost.gif" alt="C++ Boost" width="277" height="86"></h3>
        </td>
        <td valign="top">
			<h1 align="center">Boost.Threads</h1>
			<h2 align="center">atomic_t</h2>
        </td>
    </tr>
</table>

<hr>

<h2>Header</h2>

<p>The <tt>atomic_t</tt> class defines an "atomic integer" type.  This class should be used
to perform thread safe operations on an integral type with out the overhead of locks. Only
a limited set of integer operations are available with an <tt>atomic_t</tt> instance.</p>

<pre>
#include &lt;boost/thread/atomic.hpp&gt;
</pre>

<h2>Public Interface</h2>

<pre>
    class atomic_t
    {
    public:
       typedef <b>implementation defined</b> value_type;

       explicit atomic_t(value_type val=0);
    };

    atomic_t::value_type read(const atomic_t&amp; x);
    atomic_t::value_type increment(atomic_t&amp; x);
    atomic_t::value_type decrement(atomic_t&amp; x);
    atomic_t::value_type swap(atomic_t&amp; x, atomic_t::value_type y);
    atomic_t::value_type compare_swap(atomic_t&amp; x, atomic_t::value_type y, atomic_t::value_type z);
</pre>

<h3>Constructor</h3>

<pre>
    atomic_t(atomic_t::value_type val=0);
</pre>

<p>Constructs an <tt>atomic_t</tt> and sets its value to <tt>val</tt>.</p>

<h3>read</h3>

<pre>
     atomic_t::value_type read(const atomic_t&amp; x);
</pre>

<p>Gets the current value of <tt>x</tt>.</p>

<h3>increment</h3>

<pre>
    atomic_t::value_type increment(atomic_t&amp; x);
</pre>

<p>Increments <tt>x</tt> and returns a value <tt>&lt; 0</tt> if the result is less than 0,
<tt>&gt; 0</tt> if the result is greater than 0 and <tt>== 0</tt> if the result is equal to
0.</p>

<h3>decrement</h3>

<pre>
    atomic_t::value_type decrement(atomic_t&amp; x);
</pre>

<p>Decrements <tt>x</tt> and returns a value <tt>&lt; 0</tt> if the result is less than 0,
<tt>&gt; 0</tt> if the result is greater than 0 and <tt>== 0</tt> if the result is equal to
0.</p>

<h3>swap</h3>

<pre>
    atomic_t::value_type swap(atomic_t&amp; x, atomic_t::value_type y);
</pre>

<p>Assigns the value of <tt>y</tt> to <tt>x</tt> and returns the value of <tt>x</tt> prior
to the swap.</p>

<h3>compare_swap</h3>

<pre>
    atomic_t::value_type compare_swap(atomic_t&amp; x, atomic_t::value_type y, atomic_t::value_type z);
</pre>

<p>Compares the value of <tt>z</tt> to the value of <tt>x</tt> and if equal sets the value of
<tt>x</tt> to the value of <tt>y</tt> and returns the value of <tt>x</tt> prior to the swap.</p>

<h2>Example Usage</h2>

<pre>
#include &lt;boost/thread/atomic.hpp&gt;
#include &lt;boost/test/test_tools.hpp&gt;

int test_main(int, char*[])
{
    boost::atomic_t a;
    BOOST_TEST_VERIFY(boost::read(a) == 0);
    BOOST_TEST_VERIFY(boost::increment(a) &gt; 0);
    BOOST_TEST_VERIFY(boost::decrement(a) == 0);
    BOOST_TEST_VERIFY(boost::swap(a, 1) == 0);
    BOOST_TEST_VERIFY(boost::swap(a, 2, 0) == 1);
    BOOST_TEST_VERIFY(boost::read(a) == 1);
}
</pre>

<hr>

<p>Revised <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B, %Y" startspan -->05 November, 2001<!--webbot bot="Timestamp" endspan i-checksum="39359" -->
</p>

<p><i>© Copyright <a href="mailto:williamkempf@hotmail.com">William E. Kempf</a>
2001 all rights reserved.</i></p>

</body>
</html>
