<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="keywords" content="threads, Boost.Threads, thread library, C++">
<link rel="stylesheet" type="text/css" href="styles.css">
<title>Boost.Threads, xtime</title>
</head>

<body bgcolor="#FFFFFF" link="#0000FF" vlink="#800080">

<table border="0" cellpadding="7" cellspacing="0" width="100%">
    <tr>
        <td valign="top" width="300">
			<h3><img src="../../../c++boost.gif" alt="C++ Boost" width="277" height="86"></h3>
        </td>
        <td valign="top">
			<h1 align="center">Boost.Threads</h1>
			<h2 align="center">xtime</h2>
        </td>
    </tr>
</table>

<hr>

<p><A href="#Introduction">Introduction</A><br>
<A href="#Header">Header</A><br>
<A href="#Synopsis">Synopsis</A><br>
<A href="#Reference">Reference</A><br>
<A href="#Example">Example</A></p>

<h2><a name="Introduction">Introduction</a></h2>

<p>The <code>xtime</code> type is used to represent a point on some time scale or
a duration in time. This type may be proposed for the C standard by Markus Kuhn.
<b>Boost.Threads</b> provides only a very minimal implementation of this proposal
and it's expected that a full implementation will be provided in Boost as a separate
library, at which time <b>Boost.Threads</b> will deprecate its implementation.</p>

<h2><a name="Header">Header</a></h2>

<pre>
#include <a href="../../../boost/thread/xtime.hpp">&lt;boost/thread/xtime.hpp&gt;</a>
</pre>

<h2><a name="Synopsis">Synopsis</a></h2>

<pre>
namespace boost {

enum
{
   TIME_UTC=1,
};

struct xtime
{
#if defined(BOOST_NO_INT64_T)
   int_fast32_t sec;
#else
   int_fast64_t sec;
#endif
   int_fast32_t nsec;
};

int xtime_get(struct xtime* xtp, int clock_type);

} // namespace boost
</pre>    

<h2><a name="Reference">Reference</a></h2>

<hr>
<h3>TIME_UTC</h3>

<p>The clock type for Coordinated Universal Time (UTC). The epoch for this clock type
is 1970-01-01 00:00:00. This is the only clock type supported by <b>Boost.Threads</b>.</p>

<hr>
<h3>xtime</h3>

<pre>
   struct xtime
   {
#if defined(BOOST_NO_INT64_T)
      int_fast32_t sec;
#else
      int_fast64_t sec;
#endif
      int_fast32_t nsec;
   };
</pre>

<p><b>sec</b> represents the whole seconds that have passed since the epoch.</p>

<p><b>nsec</b> represents the nanoseconds since <code>sec.</code>

<hr>
<h3>xtime_get</h3>

<pre>
   int xtime_get(struct xtime* xtp, int clock_type);
</pre>

<p><b>Postcondition:</b> <code>xtp</code> represents the current point in time
as a duration since the epoch specified by the <code>clock_type</code>.</p>

<p><b>Returns:</b> <code>clock_type</code> if successful, otherwise 0.

<p><b>Notes:</b> The resolution is implementation specific. For many
implementations the best resolution of time is far more than one nanosecond, and
even when the resolution is reasonably good, the latency of a call to <code>xtime_get()</code>
may be significant. For maximum portability, avoid durations of less than
one second.</p>

<hr>
<h2><a name="Example">Example Usage</a></h2>

<pre>
#include <a href="../../../boost/thread/thread.hpp">&lt;boost/thread/thread.hpp&gt;</a>
#include <a href="../../../boost/thread/tss.hpp">&lt;boost/thread/xtime.hpp&gt;</a>

int main(int argc, char* argv[])
{
   boost::xtime xt;
   boost::xtime_get(&amp;xt, boost::TIME_UTC);
   xt.sec += 1;
   boost::thread::sleep(xt); // Sleep for 1 second
}
</pre>

<hr>

<p>Revised <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B, %Y" startspan -->01 October, 2001<!--webbot bot="Timestamp" endspan i-checksum="38291" -->
</p>

<p><i>© Copyright <a href="mailto:williamkempf@hotmail.com">William E. Kempf</a>
2001 all rights reserved.</i></p>

</body>
</html>
