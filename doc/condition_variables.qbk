[/
  (C) Copyright 2007-11 Anthony Williams.
  (C) Copyright 2011-12 Vicente J. Botet Escriba.
  (C) Copyright 2014 Niall Douglas
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[section:condvar_ref Condition Variables]

[heading Synopsis]

  namespace boost 
  {
    enum class cv_status;
    {
      no_timeout,
      timeout
    };
    class condition_variable;
    class condition_variable_any;
    void notify_all_at_thread_exit(condition_variable& cond, unique_lock<mutex> lk);
  }

The classes `condition_variable` and `condition_variable_any` provide a
closest-to-the-metal mechanism for one thread to wait for notification from
another thread that a particular condition has become true. The general usage
pattern is that one thread locks a mutex and then calls `wait` on an instance of
`condition_variable` or `condition_variable_any`. When the thread is woken from
the wait, then it checks to see if the appropriate condition is now true, and
continues if so. If the condition is not true, then the thread then calls `wait`
again to resume waiting. In the simplest case, this condition is just a boolean
variable:

    boost::condition_variable cond;
    boost::mutex mut;
    bool data_ready;

    void process_data();

    void wait_for_data_to_process()
    {
        boost::unique_lock<boost::mutex> lock(mut);
        while(!data_ready)
        {
            cond.wait(lock);
        }
        process_data();
    }

Notice that the `lock` is passed to `wait`: `wait` will atomically add the
thread to the set of threads waiting on the condition variable, and unlock the
mutex. When the thread is woken, the mutex will be locked again before the call
to `wait` returns. This allows other threads to acquire the mutex in order to
update the shared data, and ensures that the data associated with the condition
is correctly synchronized.

In the mean time, another thread sets the condition to `true`, and then calls
either `notify_one` or `notify_all` on the condition variable to wake one
waiting thread or all the waiting threads respectively.

    void retrieve_data();
    void prepare_data();

    void prepare_data_for_processing()
    {
        retrieve_data();
        prepare_data();
        {
            boost::lock_guard<boost::mutex> lock(mut);
            data_ready=true;
        }
        cond.notify_one();
    }

Note that the same mutex is locked before the shared data is updated, but that
the mutex does not have to be locked across the call to `notify_one`.

This example uses an object of type `condition_variable`, but would work just as
well with an object of type `condition_variable_any`: `condition_variable_any`
is more general, and will work with any kind of lock or mutex, whereas
`condition_variable` requires that the lock passed to `wait` is an instance of
`boost::unique_lock<boost::mutex>`. This enables `condition_variable` to make
optimizations in some cases, based on the knowledge of the mutex type;
`condition_variable_any` typically has a more complex implementation than
`condition_variable`.

[warning Be careful of directly using condition variables in your code!]

(The following section is written by Niall Douglas to explain why you should
choose `boost::permit<>` instead of condition variables unless you have a good
reason not to. Any errors are his alone)

Very little code which directly uses condition variables is completely problem
free -- condition variables are a threading ['primitive] for a reason, but
unlike the other threading primitives they are particularly easy to write
faulty code against. A very good sign of incorrect usage is when a wait
is not surrounded with a loop testing a predicate as condition variables
are prone to spurious wakeups, but even with judicious use of predicates
there are also problems with ["lost wakeups] in most code directly using
condition variables.

As a quick survey of the very subtle dragons which live here, let
us look at a common code pattern directly using condition variables:

    boost::condition_variable done;
    int result=0;
    boost::thread([&]{
        result=78;
        done.notify_one();
    });
    boost::mutex lock;
    boost::unique_lock<decltype(lock)> guard(lock);
    done.wait(guard, [&result] { return result!=0; });

This code is unsafe because result may not get set by the time the wait
predicate is checked, but may have become set and the notify issued before
the wait begins. This is an example of a lost wakeup.

An improved example might look like this:

    boost::condition_variable done;
    boost::mutex lock;
    int result=0;
    boost::thread([&]{
        {
            boost::lock_guard<decltype(lock)> guard(lock);
            result=78;
        }
        done.notify_one();
    });
    boost::unique_lock<decltype(lock)> guard(lock);
    done.wait(guard, [&result] { return result!=0; });

The above code may look safe: the predicate check for result being non-zero should
correctly detect if the thread executes and notifies before the lock in the main
thread is taken right? Potentially not: this is because `done.wait(guard, pred)`
is implemented as:

    while(!pred())
        wait(guard);

And the compiler's optimiser is permitted by the standard to believe that `result`
has not changed between its initialisation and the first test of its value, so in
fact the optimiser could compile this instead by eliding the first test of result
under the assumption that the predicate will always be false for its first execution:

    do {
        wait(guard);
    } while(!pred());

Now the race is obvious: if the closure could be executed by the spawned thread
and do the condition variable notify before the main thread gets to the point
of waiting, and the compiler's optimiser moves the test of the predicate to after the
condition variables sleep, the wakeup is ["lost]. I am not claiming any current
compiler actually does this, but I am claiming that one is depending on ["just happens]
behaviour, which is bad.


Here is another example, this time an artefact of a Boost.Thread implementation detail:

    boost::condition_variable done;
    boost::mutex lock;
    boost::unique_lock<decltype(lock)> guard(lock);
    int result=0;
    boost::thread([&]{
        {
            boost::lock_guard<decltype(lock)> guard(lock);
            result=78;
        }
        done.notify_one();
    });
    done.wait(guard, [&result] { return result!=0; });


only lost wakeup safe if and only if thread interruption support
is enabled (which it is by default). The fact it is lost wakeup safe is due to an
implementation detail: if thread interruptions are
enabled, Boost.Thread doesn't actually atomically unlock your mutex during the wait
as it is supposed to. It actually passes an internal mutex to the wait, and locks
that same internal mutex during notifies, thus effectively ['emulating] the atomicity
of the mutex unlock by forcing notifies to only occur when the underlying OS has
atomically unlocked the internal mutex. In the example above, if the notify is
called during the short window between Boost.Thread manually unlocking `guard` and
starting the wait, the notify will block on the internal mutex, thus not losing the wake.
[Incidentally, `condition_variable_any` always does this emulation of atomic unlock
via an internal mutex, it's why it's slower than standard condition variables].

If you disable thread interruptions, you may well now lose wakeups because in the tiny
window -- or more likely
as C++ 11/14 becomes popular, if someone naively converted over the Boost code to
use `std::condition_variable` they may get a nasty surprise depending on the STL
implementation. The only completely race free solution is to always notify while
holding the mutex, or if that isn't possible to loop the `notify_one()` with a check to see if
the wait has exited, so the following code is in fact race free and a correct use
of condition variables:

    boost::condition_variable done;
    boost::mutex lock;
    int result=0;
        boost::atomic<bool> woken(false);
    boost::unique_lock<decltype(lock)> guard(lock);
    boost::thread([&]{
        {
            boost::lock_guard<decltype(lock)> guard2(lock);
            result=78;
        }
        while(!woken) {
            done.notify_one();
            boost::this_thread::yield();
        }
    });
    done.wait(guard, [&result] { return result!=0; });
    woken=true;

As Hans Boehm once told me, a good sign of correct condition variable usage is when
there are predicate testing loops on [*both] the wait and the notify (he was referring
to raw POSIX condition variables). If your current
usage of condition variables is not predicate looping both waits and notifies, you may
have a lost wakeup problem which likely would only present itself when the CPU is
under very heavy load.

Due to a lot of preexisting C++ code using condition variables in variously unsafe
ways, in Boost v1.56 [link thread.synchronization.permit_ref a new safe notification
object called a permit was added] which acts very similarly to condition variables,
but is very hard to accidentally misuse. `boost::permit<>` and `boost::permit_any<>` are
generally API compatible with condition variables, thus allowing easy retrofitting
of legacy C++ code.

[section:condition_variable Class `condition_variable`]

    //#include <boost/thread/condition_variable.hpp>

    namespace boost
    {
        class condition_variable
        {
        public:
            condition_variable();
            ~condition_variable();

            void notify_one() noexcept;
            void notify_all() noexcept;

            void wait(boost::unique_lock<boost::mutex>& lock);

            template<typename predicate_type>
            void wait(boost::unique_lock<boost::mutex>& lock,predicate_type predicate);

            template <class Clock, class Duration>
            typename cv_status::type
            wait_until(
                unique_lock<mutex>& lock,
                const chrono::time_point<Clock, Duration>& t);

            template <class Clock, class Duration, class Predicate>
            bool
            wait_until(
                unique_lock<mutex>& lock,
                const chrono::time_point<Clock, Duration>& t,
                Predicate pred);

            template <class Rep, class Period>
            typename cv_status::type
            wait_for(
                unique_lock<mutex>& lock,
                const chrono::duration<Rep, Period>& d);

            template <class Rep, class Period, class Predicate>
            bool
            wait_for(
                unique_lock<mutex>& lock,
                const chrono::duration<Rep, Period>& d,
                Predicate pred);

        #if defined BOOST_THREAD_USES_DATETIME
            bool timed_wait(boost::unique_lock<boost::mutex>& lock,boost::system_time const& abs_time);
            template<typename duration_type>
            bool timed_wait(boost::unique_lock<boost::mutex>& lock,duration_type const& rel_time);
            template<typename predicate_type>
            bool timed_wait(boost::unique_lock<boost::mutex>& lock,boost::system_time const& abs_time,predicate_type predicate);
            template<typename duration_type,typename predicate_type>
            bool timed_wait(boost::unique_lock<boost::mutex>& lock,duration_type const& rel_time,predicate_type predicate);
            bool timed_wait(boost::unique_lock<boost::mutex>& lock,boost::xtime const& abs_time);

            template<typename predicate_type>
            bool timed_wait(boost::unique_lock<boost::mutex>& lock,boost::xtime const& abs_time,predicate_type predicate);
        #endif

        };
    }

[section:constructor `condition_variable()`]

[variablelist

[[Effects:] [Constructs an object of class `condition_variable`.]]

[[Throws:] [__thread_resource_error__ if an error occurs.]]

]

[endsect]

[section:destructor `~condition_variable()`]

[variablelist

[[Precondition:] [All threads waiting on `*this` have been notified by a call to
`notify_one` or `notify_all` (though the respective calls to `wait` or
`timed_wait` need not have returned).]]

[[Effects:] [Destroys the object.]]

[[Throws:] [Nothing.]]

]

[endsect]

[section:notify_one `void notify_one()`]

[variablelist

[[Effects:] [If any threads are currently __blocked__ waiting on `*this` in a call
to `wait` or `timed_wait`, unblocks one of those threads.]]

[[Throws:] [Nothing.]]

]

[endsect]

[section:notify_all `void notify_all()`]

[variablelist

[[Effects:] [If any threads are currently __blocked__ waiting on `*this` in a call
to `wait` or `timed_wait`, unblocks all of those threads.]]

[[Throws:] [Nothing.]]

]

[endsect]

[section:wait `void wait(boost::unique_lock<boost::mutex>& lock)`]

[variablelist

[[Precondition:] [`lock` is locked by the current thread, and either no other
thread is currently waiting on `*this`, or the execution of the `mutex()` member
function on the `lock` objects supplied in the calls to `wait` or `timed_wait`
in all the threads currently waiting on `*this` would return the same value as
`lock->mutex()` for this call to `wait`.]]

[[Effects:] [Atomically call `lock.unlock()` and blocks the current thread. The
thread will unblock when notified by a call to `this->notify_one()` or
`this->notify_all()`, or spuriously. When the thread is unblocked (for whatever
reason), the lock is reacquired by invoking `lock.lock()` before the call to
`wait` returns. The lock is also reacquired by invoking `lock.lock()` if the
function exits with an exception.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[endsect]

[section:wait_predicate `template<typename predicate_type> void wait(boost::unique_lock<boost::mutex>& lock, predicate_type pred)`]

[variablelist

[[Effects:] [As-if ``
while(!pred())
{
    wait(lock);
}
``]]

]

[endsect]

[section:timed_wait `bool timed_wait(boost::unique_lock<boost::mutex>& lock,boost::system_time const& abs_time)`]

[variablelist

[[Precondition:] [`lock` is locked by the current thread, and either no other
thread is currently waiting on `*this`, or the execution of the `mutex()` member
function on the `lock` objects supplied in the calls to `wait` or `timed_wait`
in all the threads currently waiting on `*this` would return the same value as
`lock->mutex()` for this call to `wait`.]]

[[Effects:] [Atomically call `lock.unlock()` and blocks the current thread. The
thread will unblock when notified by a call to `this->notify_one()` or
`this->notify_all()`, when the time as reported by `boost::get_system_time()`
would be equal to or later than the specified `abs_time`, or spuriously. When
the thread is unblocked (for whatever reason), the lock is reacquired by
invoking `lock.lock()` before the call to `wait` returns. The lock is also
reacquired by invoking `lock.lock()` if the function exits with an exception.]]

[[Returns:] [`false` if the call is returning because the time specified by
`abs_time` was reached, `true` otherwise.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[endsect]

[section:timed_wait_rel `template<typename duration_type> bool timed_wait(boost::unique_lock<boost::mutex>& lock,duration_type const& rel_time)`]

[variablelist

[[Precondition:] [`lock` is locked by the current thread, and either no other
thread is currently waiting on `*this`, or the execution of the `mutex()` member
function on the `lock` objects supplied in the calls to `wait` or `timed_wait`
in all the threads currently waiting on `*this` would return the same value as
`lock->mutex()` for this call to `wait`.]]

[[Effects:] [Atomically call `lock.unlock()` and blocks the current thread. The
thread will unblock when notified by a call to `this->notify_one()` or
`this->notify_all()`, after the period of time indicated by the `rel_time`
argument has elapsed, or spuriously. When the thread is unblocked (for whatever
reason), the lock is reacquired by invoking `lock.lock()` before the call to
`wait` returns. The lock is also reacquired by invoking `lock.lock()` if the
function exits with an exception.]]

[[Returns:] [`false` if the call is returning because the time period specified
by `rel_time` has elapsed, `true` otherwise.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[note The duration overload of timed_wait is difficult to use correctly. The overload taking a predicate should be preferred in most cases.]

[endsect]

[section:timed_wait_predicate `template<typename predicate_type> bool timed_wait(boost::unique_lock<boost::mutex>& lock, boost::system_time const& abs_time, predicate_type pred)`]

[variablelist

[[Effects:] [As-if ``
while(!pred())
{
    if(!timed_wait(lock,abs_time))
    {
        return pred();
    }
}
return true;
``]]

]

[endsect]


[section:wait_until `template <class Clock, class Duration> cv_status wait_until(boost::unique_lock<boost::mutex>& lock, const chrono::time_point<Clock, Duration>& abs_time)`]

[variablelist

[[Precondition:] [`lock` is locked by the current thread, and either no other
thread is currently waiting on `*this`, or the execution of the `mutex()` member
function on the `lock` objects supplied in the calls to `wait` or `wait_for` or `wait_until`
in all the threads currently waiting on `*this` would return the same value as
`lock->mutex()` for this call to `wait`.]]

[[Effects:] [Atomically call `lock.unlock()` and blocks the current thread. The
thread will unblock when notified by a call to `this->notify_one()` or
`this->notify_all()`, when the time as reported by `Clock::now()`
would be equal to or later than the specified `abs_time`, or spuriously. When
the thread is unblocked (for whatever reason), the lock is reacquired by
invoking `lock.lock()` before the call to `wait` returns. The lock is also
reacquired by invoking `lock.lock()` if the function exits with an exception.]]

[[Returns:] [`cv_status::timeout` if the call is returning because the time specified by
`abs_time` was reached, `cv_status::no_timeout` otherwise.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[endsect]

[section:wait_for `template <class Rep, class Period> cv_status wait_for(boost::unique_lock<boost::mutex>& lock, const chrono::duration<Rep, Period>& rel_time)`]


[variablelist

[[Precondition:] [`lock` is locked by the current thread, and either no other
thread is currently waiting on `*this`, or the execution of the `mutex()` member
function on the `lock` objects supplied in the calls to `wait` or `wait_until` or `wait_for`
in all the threads currently waiting on `*this` would return the same value as
`lock->mutex()` for this call to `wait`.]]

[[Effects:] [Atomically call `lock.unlock()` and blocks the current thread. The
thread will unblock when notified by a call to `this->notify_one()` or
`this->notify_all()`, after the period of time indicated by the `rel_time`
argument has elapsed, or spuriously. When the thread is unblocked (for whatever
reason), the lock is reacquired by invoking `lock.lock()` before the call to
`wait` returns. The lock is also reacquired by invoking `lock.lock()` if the
function exits with an exception.]]

[[Returns:] [`cv_status::timeout ` if the call is returning because the time period specified
by `rel_time` has elapsed, `cv_status::no_timeout ` otherwise.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[note The duration overload of timed_wait is difficult to use correctly. The overload taking a predicate should be preferred in most cases.]

[endsect]

[section:wait_until_predicate `template <class Clock, class Duration, class Predicate> bool wait_until(boost::unique_lock<boost::mutex>& lock, const chrono::time_point<Clock, Duration>& abs_time, Predicate pred)`]


[variablelist

[[Effects:] [As-if ``
while(!pred())
{
    if(!wait_until(lock,abs_time))
    {
        return pred();
    }
}
return true;
``]]

]

[endsect]

[section:wait_for_predicate `template <class Rep, class Period, class Predicate> bool wait_for(boost::unique_lock<boost::mutex>& lock, const chrono::duration<Rep, Period>& rel_time, Predicate pred)`]


[variablelist

[[Effects:] [As-if ``
return wait_until(lock, chrono::steady_clock::now() + d, boost::move(pred));
``]]

]

[endsect]




[endsect]

[section:condition_variable_any Class `condition_variable_any`]

    //#include <boost/thread/condition_variable.hpp>

    namespace boost
    {
        class condition_variable_any
        {
        public:
            condition_variable_any();
            ~condition_variable_any();

            void notify_one();
            void notify_all();

            template<typename lock_type>
            void wait(lock_type& lock);

            template<typename lock_type,typename predicate_type>
            void wait(lock_type& lock,predicate_type predicate);

            template <class lock_type, class Clock, class Duration>
            cv_status wait_until(
                lock_type& lock,
                const chrono::time_point<Clock, Duration>& t);

            template <class lock_type, class Clock, class Duration, class Predicate>
            bool wait_until(
                lock_type& lock,
                const chrono::time_point<Clock, Duration>& t,
                Predicate pred);


            template <class lock_type, class Rep, class Period>
            cv_status wait_for(
                lock_type& lock,
                const chrono::duration<Rep, Period>& d);

            template <class lock_type, class Rep, class Period, class Predicate>
            bool wait_for(
                lock_type& lock,
                const chrono::duration<Rep, Period>& d,
                Predicate pred);

        #if defined BOOST_THREAD_USES_DATETIME
            template<typename lock_type>
            bool timed_wait(lock_type& lock,boost::system_time const& abs_time);
            template<typename lock_type,typename duration_type>
            bool timed_wait(lock_type& lock,duration_type const& rel_time);
            template<typename lock_type,typename predicate_type>
            bool timed_wait(lock_type& lock,boost::system_time const& abs_time,predicate_type predicate);
            template<typename lock_type,typename duration_type,typename predicate_type>
            bool timed_wait(lock_type& lock,duration_type const& rel_time,predicate_type predicate);
            template<typename lock_type>
            bool timed_wait(lock_type>& lock,boost::xtime const& abs_time);
            template<typename lock_type,typename predicate_type>
            bool timed_wait(lock_type& lock,boost::xtime const& abs_time,predicate_type predicate);
        #endif
        };
    }

[section:constructor `condition_variable_any()`]

[variablelist

[[Effects:] [Constructs an object of class `condition_variable_any`.]]

[[Throws:] [__thread_resource_error__ if an error occurs.]]

]

[endsect]

[section:destructor `~condition_variable_any()`]

[variablelist

[[Precondition:] [All threads waiting on `*this` have been notified by a call to
`notify_one` or `notify_all` (though the respective calls to `wait` or
`timed_wait` need not have returned).]]

[[Effects:] [Destroys the object.]]

[[Throws:] [Nothing.]]

]

[endsect]

[section:notify_one `void notify_one()`]

[variablelist

[[Effects:] [If any threads are currently __blocked__ waiting on `*this` in a call
to `wait` or `timed_wait`, unblocks one of those threads.]]

[[Throws:] [Nothing.]]

]

[endsect]

[section:notify_all `void notify_all()`]

[variablelist

[[Effects:] [If any threads are currently __blocked__ waiting on `*this` in a call
to `wait` or `timed_wait`, unblocks all of those threads.]]

[[Throws:] [Nothing.]]

]

[endsect]

[section:wait `template<typename lock_type> void wait(lock_type& lock)`]

[variablelist

[[Effects:] [Atomically call `lock.unlock()` and blocks the current thread. The
thread will unblock when notified by a call to `this->notify_one()` or
`this->notify_all()`, or spuriously. When the thread is unblocked (for whatever
reason), the lock is reacquired by invoking `lock.lock()` before the call to
`wait` returns. The lock is also reacquired by invoking `lock.lock()` if the
function exits with an exception.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[endsect]

[section:wait_predicate `template<typename lock_type,typename predicate_type> void wait(lock_type& lock, predicate_type pred)`]

[variablelist

[[Effects:] [As-if ``
while(!pred())
{
    wait(lock);
}
``]]

]

[endsect]

[section:timed_wait `template<typename lock_type> bool timed_wait(lock_type& lock,boost::system_time const& abs_time)`]

[variablelist

[[Effects:] [Atomically call `lock.unlock()` and blocks the current thread. The
thread will unblock when notified by a call to `this->notify_one()` or
`this->notify_all()`, when the time as reported by `boost::get_system_time()`
would be equal to or later than the specified `abs_time`, or spuriously. When
the thread is unblocked (for whatever reason), the lock is reacquired by
invoking `lock.lock()` before the call to `wait` returns. The lock is also
reacquired by invoking `lock.lock()` if the function exits with an exception.]]

[[Returns:] [`false` if the call is returning because the time specified by
`abs_time` was reached, `true` otherwise.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[endsect]

[section:timed_wait_rel `template<typename lock_type,typename duration_type> bool timed_wait(lock_type& lock,duration_type const& rel_time)`]

[variablelist

[[Effects:] [Atomically call `lock.unlock()` and blocks the current thread. The
thread will unblock when notified by a call to `this->notify_one()` or
`this->notify_all()`, after the period of time indicated by the `rel_time`
argument has elapsed, or spuriously. When the thread is unblocked (for whatever
reason), the lock is reacquired by invoking `lock.lock()` before the call to
`wait` returns. The lock is also reacquired by invoking `lock.lock()` if the
function exits with an exception.]]

[[Returns:] [`false` if the call is returning because the time period specified
by `rel_time` has elapsed, `true` otherwise.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[note The duration overload of timed_wait is difficult to use correctly. The overload taking a predicate should be preferred in most cases.]

[endsect]

[section:timed_wait_predicate `template<typename lock_type,typename predicate_type> bool timed_wait(lock_type& lock, boost::system_time const& abs_time, predicate_type pred)`]

[variablelist

[[Effects:] [As-if ``
while(!pred())
{
    if(!timed_wait(lock,abs_time))
    {
        return pred();
    }
}
return true;
``]]

]

[endsect]

[section:wait_until `template <class lock_type, class Clock, class Duration> cv_status wait_until(lock_type& lock, const chrono::time_point<Clock, Duration>& abs_time)`]

[variablelist

[[Effects:] [Atomically call `lock.unlock()` and blocks the current thread. The
thread will unblock when notified by a call to `this->notify_one()` or
`this->notify_all()`, when the time as reported by `Clock::now()`
would be equal to or later than the specified `abs_time`, or spuriously. When
the thread is unblocked (for whatever reason), the lock is reacquired by
invoking `lock.lock()` before the call to `wait` returns. The lock is also
reacquired by invoking `lock.lock()` if the function exits with an exception.]]

[[Returns:] [`cv_status::timeout` if the call is returning because the time specified by
`abs_time` was reached, `cv_status::no_timeout` otherwise.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[endsect]

[section:wait_for `template <class lock_type, class Rep, class Period> cv_status wait_for(lock_type& lock, const chrono::duration<Rep, Period>& rel_time)`]

[variablelist

[[Effects:] [Atomically call `lock.unlock()` and blocks the current thread. The
thread will unblock when notified by a call to `this->notify_one()` or
`this->notify_all()`, after the period of time indicated by the `rel_time`
argument has elapsed, or spuriously. When the thread is unblocked (for whatever
reason), the lock is reacquired by invoking `lock.lock()` before the call to
`wait` returns. The lock is also reacquired by invoking `lock.lock()` if the
function exits with an exception.]]

[[Returns:] [`cv_status::timeout` if the call is returning because the time specified by
`abs_time` was reached, `cv_status::no_timeout` otherwise.]]

[[Postcondition:] [`lock` is locked by the current thread.]]

[[Throws:] [__thread_resource_error__ if an error
occurs. __thread_interrupted__ if the wait was interrupted by a call to
__interrupt__ on the __thread__ object associated with the current thread of execution.]]

]

[note The duration overload of timed_wait is difficult to use correctly. The overload taking a predicate should be preferred in most cases.]

[endsect]

[section:wait_until_predicate `template <class lock_type, class Clock, class Duration, class Predicate> bool wait_until(lock_type& lock, const chrono::time_point<Clock, Duration>& abs_time, Predicate pred)`]

[variablelist

[[Effects:] [As-if ``
while(!pred())
{
    if(!__cvany_wait_until(lock,abs_time))
    {
        return pred();
    }
}
return true;
``]]

]

[endsect]

[section:wait_for_predicate `template <class lock_type, class Rep, class Period, class Predicate> bool wait_for(lock_type& lock, const chrono::duration<Rep, Period>& rel_time, Predicate pred)`]

[variablelist

[[Effects:] [As-if ``
return wait_until(lock, chrono::steady_clock::now() + d, boost::move(pred));
``]]

]

[endsect]

[endsect]

[section:condition Typedef `condition` DEPRECATED V3]

  // #include <boost/thread/condition.hpp>
  namespace boost 
  {

    typedef condition_variable_any condition;

  }

The typedef `condition` is provided for backwards compatibility with previous boost releases.

[endsect]


[section:notify_all_at_thread_exit Non-member Function `notify_all_at_thread_exit`()]

  // #include <boost/thread/condition_variable.hpp>

  namespace boost
  {
    void notify_all_at_thread_exit(condition_variable& cond, unique_lock<mutex> lk);
  }

[variablelist

[[Requires:] [`lk` is locked by the calling thread and either no other thread is waiting on `cond`, or `lk.mutex()` returns the same value for each of the lock arguments supplied by all concurrently waiting (via `wait`, `wait_for`, or `wait_until`) threads.]]
[[Effects:] [transfers ownership of the lock associated with `lk` into internal storage and schedules `cond` to be notified when the current thread exits, after all objects of thread storage duration associated with the current thread have been destroyed. This notification shall be as if

``
  lk.unlock();
  cond.notify_all();
``

]]

]

[/
[[Synchronization:] [The call to notify_all_at_thread_exit and the completion of the destructors for all the current thread�s variables of thread storage duration synchronize with (1.10) calls to functions waiting on cond.
]]
[[Note:] [The supplied lock will be held until the thread exits, and care must be taken to ensure that this does not cause deadlock due to lock ordering issues. After calling notify_all_at_thread_exit it is recommended that the thread should be exited as soon as possible, and that no blocking or time-consuming tasks are run on that thread.
]]
[[Note:] [It is the user�s responsibility to ensure that waiting threads do not erroneously assume that the thread has finished if they experience spurious wakeups. This typically requires that the condition being waited for is satisfied while holding the lock on lk, and that this lock is not released and reacquired prior to calling notify_all_at_thread_exit.
]]
]

[endsect]

[endsect]
