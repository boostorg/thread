<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../../boost.css">
<title>Boost.Threads - Header &lt;boost/thread/condition.hpp&gt;</title>
</head>
<body link="#0000ff" vlink="#800080">
<table border="0" cellpadding="7" cellspacing="0" width="100%" summary=
    "header">
  <tr> 
    <td valign="top" width="300"> 
      <h3><a href="../../../index.htm"><img height="86" width="277" alt="C++ Boost" src="../../../c++boost.gif" border="0"></a></h3>
    </td>
    <td valign="top"> 
      <h1 align="center">Boost.Threads</h1>
      <h2 align="center">Header &lt;<a href="../../../boost/thread/condition.hpp">boost/thread/condition.hpp</a>&gt;</h2>
    </td>
  </tr>
</table>
<hr>
<h2>Contents</h2>
<dl class="page-index"> 
  <dt><a href="#introduction">Introduction</a></dt>
  <dt><a href="#classes">Classes</a></dt>
  <dl class="page-index"> 
    <dt><a href="#class-condition">Class <code>condition</code></a></dt>
    <dl class="page-index"> 
      <dt><a href="#class-condition-synopsis">Class <code>condition</code> synopsis</a></dt>
      <dt><a href="#class-condition-ctors">Class <code>condition</code> constructors 
        and destructor</a></dt>
      <dt><a href="#class-condition-modifiers">Class <code>condition</code> modifier 
        functions</a></dt>
    </dl>
  </dl>
  <dt><a href="#examples">Example(s)</a></dt>
</dl>
<hr>
<h2><a name="introduction"></a>Introduction</h2>
<p>{{Introductory text}}</p>
<h2><a name="classes"></a>Classes</h2>
<h3><a name="class-condition"></a>Class <code>condition</code></h3>
<p>An object of class <code>condition</code> is a synchronization primitive used 
  to cause a thread to wait until a particular shared-data condition (or time) 
  is met. A <code>condition</code> object is always used in conjunction with a 
  mutex object modeling a <a href="mutex_concept.html">Mutex Concept</a>. The mutex must be locked prior 
  to waiting on the <code>condition</code>, which is ensured by passing a lock 
  object modeling a <a href="lock_concept.html">Lock Concept</a> to the <code>condition</code> 
  object&#39;s <code>wait</code> functions. While the thread is waiting on the 
  <code>condition</code> object, the mutex associated with the lock is unlocked. 
  When the thread returns from a call to one of the <code>condition</code> object&#39;s 
  <code> wait</code> functions, the mutex is again locked. The tricky lock/unlock/lock 
  sequence is performed automatically by the <code> condition</code> object&#39;s 
  <code>wait</code> functions.</p>
<p>The <code>condition</code> type is often used to implement the <i> Monitor 
  Object</i> and other important patterns. See <a href="bibliography.html#Schmidt-00">[Schmidt-00]</a> and <a href="bibliography.html#Hoare-74">[Hoare 74]</a>. Monitors are one of the most 
  important patterns for creating reliable multithreaded programs.</p>
<p>See <a href="definitions.html">Formal Definitions</a> for definitions of thread 
  states <a href="definitions.html#state"> blocked</a> and <a href="definitions.html#state">ready</a>. 
  Note that &quot;waiting&quot; is a synonym for blocked.</p>
<h4><a name="class-condition-synopsis"></a>Class <code>condition</code> synopsis</h4>
<pre>
namespace boost
{
    class condition : private <a href="../../utility/utility.htm#Class noncopyable">boost::noncopyable</a> // Exposition only.
       // Class condition meets the <a href="overview.html#NonCopyable">NonCopyable</a> requirement.
    {
    public:
        condition();
        ~condition();

        void notify_one();
        void notify_all();
        template &lt;typename <a href="scoped_lock.html">ScopedLock</a>&gt;
            void wait(<a href="scoped_lock.html">ScopedLock</a>&amp; lock);
        template &lt;typename <a href="scoped_lock.html">ScopedLock</a>, typename <a href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a>&gt;
            void wait(<a href="scoped_lock.html">ScopedLock</a>&amp; lock, <a href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a> pred);
        template &lt;typename <a href="scoped_lock.html">ScopedLock</a>&gt;
            bool timed_wait(<a href="scoped_lock.html">ScopedLock</a>&amp; lock, const xtime&amp; xt);
        template &lt;typename <a href="scoped_lock.html">ScopedLock</a>, typename <a href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a>&gt;
            bool timed_wait(<a href="scoped_lock.html">ScopedLock</a>&amp; lock, const xtime&amp; xt, <a href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a> pred);
    };
};
</pre>
<h4><a name="class-spec-ctors"></a>Class <code>condition</code> constructors and 
  destructor</h4>
<pre>
condition();
</pre>
<dl class="function-semantics"> 
  <dt><b>Effects:</b> Constructs a <code>condition</code> object.</dt>
</dl>
<pre>
~condition();
</pre>
<dl class="function-semantics"> 
  <dt><b>Effects:</b> Destroys <code>*this</code>.</dt>
</dl>
<h4><a name="class-spec-modifiers"></a>Class <code>condition</code> modifier functions</h4>
<pre>
void notify_one();
</pre>
<dl class="function-semantics"> 
  <dt><b>Effects:</b> If there is a thread waiting on <code>*this</code>, change 
    that thread&#39;s state to ready. Otherwise there is no effect.</dt>
  <dt><b>Note:</b> If more that one thread is waiting on the condition, it is 
    unspecified which is made ready.</dt>
</dl>
<pre>
void notify_all();
</pre>
<dl class="function-semantics"> 
  <dt><b>Effects:</b> Change the state of all threads waiting on <code> *this</code> 
    to ready. If there are no waiting threads, <code> notify_all()</code> has 
    no effect.</dt>
</dl>
<pre>
template &lt;typename ScopedLock&gt;
    void wait(ScopedLock&amp; lock);
</pre>
<dl class="function-semantics"> 
  <dt><b>Requires:</b> <code>ScopedLock</code> meets the <a href="lock_concept.html#ScopedLock">ScopedLock</a> requirements.</dt>
  <dt><b>Effects:</b> Releases the lock on the <a href="mutex_concept.html">mutex model</a> associated with <code>lock</code>, 
    blocks the current thread of execution until readied by a call to <code>this-&gt;notify_one()</code> 
    or <code> this-&gt;notify_all()</code>, and then reacquires the lock. All 
    effects occur in an atomic fashion.</dt>
  <dt><b>Throws:</b> <code><a href="lock_error.html">lock_error</a></code> if 
    <code>!lock.locked()</code></dt>
  <dt><b>Danger:</b> This version should always be used within a loop checking 
    that the state logically associated with the <code>condition</code> has become 
    true. Without the loop, race conditions can ensue due to possible &quot;spurious 
    wake ups&quot;. The second version encapsulates this loop idiom internally 
    and is generally the preferred method.</dt>
</dl>
<pre>
template &lt;typename ScopedLock, typename Pr&gt;
    void wait(ScopedLock&amp; lock, Pr pred);
</pre>
<dl class="function-semantics"> 
  <dt><b>Requires:</b> <code>ScopedLock</code> meets the <a href="lock_concept.html#ScopedLock">ScopedLock</a> requirements, return from 
    <code>pred()</code> convertible to bool.</dt>
  <dt><b>Effects:</b> As if: <code>while (!pred()) wait(lock)</code></dt>
  <dt><b>Throws:</b> <code><a href="lock_error.html">lock_error</a></code> if 
    <code>!lock.locked()</code></dt>
</dl>
<pre>
template &lt;typename ScopedLock&gt;
    bool timed_wait(ScopedLock&amp; lock, const <a href="xtime.html">xtime</a>&amp; xt);
</pre>
<dl class="function-semantics"> 
  <dt><b>Requires:</b> <code>ScopedLock</code> meets the <a href="lock_concept.html#ScopedLock">ScopedLock</a> requirements.</dt>
  <dt><b>Effects:</b> Releases the lock on the <a href="mutex_concept.html">mutex model</a> associated with the <code> lock</code>, 
    blocks the current thread of execution until readied by a call to <code>this-&gt;notify_one()</code> 
    or <code> this-&gt;notify_all()</code>, or until <code>xt</code>, and then 
    reacquires the lock. All effects occur in an atomic fashion.</dt>
  <dt><b>Returns:</b> <code>false</code> if <code>xt</code> is reached, otherwise 
    <code>true</code>.</dt>
  <dt><b>Throws:</b> <code><a href="lock_error.html">lock_error</a></code> if 
    <code>!lock.locked()</code></dt>
  <dt><b>Danger:</b> This version should always be used within a loop checking 
    that the state logically associated with the <code>condition</code> has become 
    true. Without the loop, race conditions can ensue due to &quot;spurious wake 
    ups&quot;. The second version encapsulates this loop idiom internally and 
    is generally the preferred method.</dt>
</dl>
<pre>
template &lt;typename ScopedLock, typename Pr&gt;
    bool timed_wait(ScopedLock&amp; lock, const <a href="xtime.html">xtime</a>&amp; xt, Pr pred);
</pre>
<dl class="function-semantics"> 
  <dt><b>Requires:</b> <code>ScopedLock</code> meets the <a href="lock_concept.html#ScopedLock">ScopedLock</a> requirements, return from 
    <code>pred()</code> convertible to bool.</dt>
  <dt><b>Effects:</b> As if:<br>
<pre>
while (!pred())
{
    if (!timed_wait(lock, xt))
        return false;
}
return true;
</pre>
  </dt>
  <dt><b>Returns:</b> <code>false</code> if <code>xt</code> is reached, otherwise 
    <code>true</code>.</dt>
  <dt><b>Throws:</b> <code><a href="lock_error.html">lock_error</a></code> if 
    <code>!lock.locked()</code></dt>
</dl>
<h2><a name="examples"></a>Example(s)</h2>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include <a href="../../../boost/utility.hpp">&lt;boost/utility.hpp&gt;</a>
#include <a href="../../../boost/thread/condition.hpp">&lt;boost/thread/condition.hpp&gt;</a>
#include <a href="../../../boost/thread/thread.hpp">&lt;boost/thread/thread.hpp&gt;</a>

class bounded_buffer : private boost::noncopyable
{
public:
    typedef boost::mutex::scoped_lock lock;

    bounded_buffer(int n) : begin(0), end(0), buffered(0), circular_buf(n) { }

    void send (int m) {
        lock lk(monitor);
        while (buffered == circular_buf.size())
            buffer_not_full.wait(lk);
        circular_buf[end] = m;
        end = (end+1) % circular_buf.size();
        ++buffered;
        buffer_not_empty.notify_one();
    }
    int receive() {
        lock lk(monitor);
        while (buffered == 0)
            buffer_not_empty.wait(lk);
        int i = circular_buf[begin];
        begin = (begin+1) % circular_buf.size();
        --buffered;
        buffer_not_full.notify_one();
        return i;
    }

private:
    int begin, end, buffered;
    std::vector&lt;int&gt; circular_buf;
    boost::condition buffer_not_full, buffer_not_empty;
    boost::mutex monitor;
};

bounded_buffer buf(2);

void sender() {
    int n = 0;
    while (n &lt; 100) {
       buf.send(n);
       std::cout &lt;&lt; &quot;sent: &quot; &lt;&lt; n &lt;&lt; std::endl;
       ++n;
    }
    buf.send(-1);
}

void receiver() {
    int n;
    do {
       n = buf.receive();
       std::cout &lt;&lt; &quot;received: &quot; &lt;&lt; n &lt;&lt; std::endl;
    } while (n != -1); // -1 indicates end of buffer
}

int main(int, char*[])
{
    boost::thread thrd1(&amp;sender);
    boost::thread thrd2(&amp;receiver);
    thrd1.join();
    thrd2.join();
    return 0;
}
</pre>
<p>Typical output (dependent on scheduling policies) is:</p>
<pre>
sent: 0
sent: 1
received: 0
received: 1
sent: 2
sent: 3
received: 2
received: 3
sent: 4
received: 4
</pre>
<p>Revised 
  <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B, %Y" startspan -->
  05 November, 2001 
  <!--webbot bot="Timestamp" endspan i-checksum="39359" -->
</p>
<p><i>&copy; Copyright <a href="mailto:wekempf@cox.net">William E. Kempf</a> 2002. All Rights 
  Reserved.</i></p>
</body>
</html>
