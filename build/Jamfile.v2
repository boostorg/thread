# $Id$
# Copyright 2006-2007 Roland Schwarz.
# Copyright 2007 Anthony Williams
# Distributed under the Boost Software License, Version 1.0. (See
# accompanying file LICENSE_1_0.txt or copy at
# http://www.boost.org/LICENSE_1_0.txt)

#########################################################################
# The boost threading library can be built on top of different API's
# Currently this is the win32 API and the pthreads API.
# Pthread is native on unix variants.
# To get pthread on windows you need the pthread win32 library
# http://sourceware.org/pthreads-win32 which is available under LGPL.
#
# You need to provide the include path and lib path in the variables
# PTW32_INCLUDE and PTW32_LIB respectively. You can specify these
# paths in site-config.jam, user-config.jam or in the environment.
# A new feature is provided to request a specific API:
# <threadapi>win32 and <threadapi)pthread.
#
# The naming of the resulting libraries is mostly the same for the
# variant native to the build platform, i.e.
# boost_thread and the boost specific tagging.
# For the library variant that is not native on the build platform
# an additional tag is applied:
# boost_thread_pthread for the pthread variant on windows, and
# boost_thread_win32 for the win32 variant (likely when built on cygwin).
#
# To request the pthread variant on windows, from boost root you would
# say e.g:
# bjam msvc-8.0 --with-thread install threadapi=pthread
#########################################################################

import os ;
import feature ;
import indirect ;
import path ;

project boost/thread
    : source-location ../src
    : requirements <threading>multi
      <link>static:<define>BOOST_THREAD_BUILD_LIB=1
      <link>shared:<define>BOOST_THREAD_BUILD_DLL=1
      -<tag>@$(BOOST_JAMROOT_MODULE)%$(BOOST_JAMROOT_MODULE).tag
      <tag>@$(__name__).tag
    : default-build <threading>multi
    ;

local rule default_threadapi ( )
{
    local api = pthread ;
    if [ os.name ] = "NT" { api = win32 ; }
    return $(api) ;
}

feature.feature threadapi : pthread win32 : propagated ;
feature.set-default threadapi : [ default_threadapi ] ;

rule tag ( name : type ? : property-set )
{
    local result = $(name) ;
    
    if $(type) in STATIC_LIB SHARED_LIB IMPORT_LIB
    {
        local api = [ $(property-set).get <threadapi> ] ;
        
        # non native api gets additional tag
        if $(api) != [ default_threadapi ] {
            result = $(result)_$(api) ;
        }
    }
    
    # forward to the boost tagging rule
    return  [ indirect.call $(BOOST_JAMROOT_MODULE)%$(BOOST_JAMROOT_MODULE).tag 
                $(result) : $(type) : $(property-set) ] ;
}

rule win32_pthread_paths ( properties * )
{
    local result ;
    local PTW32_INCLUDE ;
    local PTW32_LIB ;
    PTW32_INCLUDE  = [ modules.peek             : PTW32_INCLUDE ] ;
    PTW32_LIB      = [ modules.peek             : PTW32_LIB     ] ;
    PTW32_INCLUDE ?= [ modules.peek user-config : PTW32_INCLUDE ] ;
    PTW32_LIB     ?= [ modules.peek user-config : PTW32_LIB     ] ;
    PTW32_INCLUDE ?= [ modules.peek site-config : PTW32_INCLUDE ] ;
    PTW32_LIB     ?= [ modules.peek site-config : PTW32_LIB     ] ;

    if ! ( $(PTW32_INCLUDE) && $(PTW32_LIB) )
    {
        if  ! $(.notified)
        {
            echo "************************************************************" ;
            echo "Trying to build Boost.Thread with pthread support."           ;
            echo "If you need pthread you should specify the paths."            ;
            echo "You can specify them in site-config.jam, user-config.jam"     ;
            echo "or in the environment."                                       ;
            echo "For example:"                                                 ;
            echo "PTW32_INCLUDE=C:\\Program Files\\ptw32\\Pre-built2\\include"  ;
            echo "PTW32_LIB=C:\\Program Files\\ptw32\\Pre-built2\\lib"          ;
            echo "************************************************************" ;
            .notified = true ;
        }
    }
    else
    {
        local include_path = [ path.make $(PTW32_INCLUDE) ] ;
        local lib_path = [ path.make $(PTW32_LIB) ] ;
        local libname = pthread ;
        if <toolset>msvc in $(properties)
        {
            libname = $(libname)VC2.lib ;
        }
        if <toolset>gcc in $(properties)
        {
            libname = lib$(libname)GC2.a ;
        }
        lib_path = [ path.glob $(lib_path) : $(libname) ] ;
        if ! $(lib_path)
        {
            if  ! $(.notified)
            {
                echo "************************************************************" ;
                echo "Trying to build Boost.Thread with pthread support."           ;
                echo "But the library" $(libname) "could not be found in path"      ;
                echo $(PTW32_LIB)                                                   ;
                echo "************************************************************" ;
                .notified = true ;
            }
        }
        else 
        {
            result += <include>$(include_path) ;
            result += <library>$(lib_path) ;
        }
    }
    return $(result) ;
}

rule usage-requirements ( properties * )
{
    local result ;
    if <threadapi>pthread in $(properties)
    {
        result += <define>BOOST_THREAD_POSIX ;
        if <target-os>windows in $(properties)
        {
            result += [ win32_pthread_paths $(properties) ] ;
            # TODO: What is for static linking? Is the <library> also needed
            # in that case?
        }
    }
    return $(result) ;
}

rule requirements ( properties * )
{
    local result ;

    if <threadapi>pthread in $(properties)
    {
        result += <define>BOOST_THREAD_POSIX ;
        if <target-os>windows in $(properties) 
        {
            local paths = [ win32_pthread_paths $(properties) ] ;
            if $(paths)
            {
                result += $(paths) ;
            }
            else
            {
                result = <build>no ;
            }
        }
    }
    return $(result) ;
}

alias thread_sources
    : ## win32 sources ##
      win32/thread.cpp
      win32/tss_dll.cpp
      win32/tss_pe.cpp
    : ## requirements ##
      <threadapi>win32
    ;

alias thread_sources
    : ## pthread sources ##
      pthread/thread.cpp
      pthread/once.cpp
    : ## requirements ##
      <threadapi>pthread
    ;

explicit thread_sources ;

lib boost_thread
    : thread_sources
    : <conditional>@requirements
    :
    : <link>shared:<define>BOOST_THREAD_USE_DLL=1
      <link>static:<define>BOOST_THREAD_USE_LIB=1
      <conditional>@usage-requirements
    ;
